{"pageProps":{"postData":{"id":"学习笔记 NextJS","contentHtml":"<p>Next.js 是一个基于 React 的服务端渲染框架，但是它能做的显然不止于此</p>\n<h3 id=\"user-content-项目初始化\"><a href=\"#%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>项目初始化</h3>\n<h4 id=\"user-content-\"></h4>\n<h3 id=\"user-content-页面展示\"><a href=\"#%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>页面展示</h3>\n<p>pages 文件夹下面的每个命名组件都作为软件的一个页面存在，</p>\n<h4 id=\"user-content-预渲染\"><a href=\"#%E9%A2%84%E6%B8%B2%E6%9F%93\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>预渲染</h4>\n<h5 id=\"user-content-静态生成-static-generation\"><a href=\"#%E9%9D%99%E6%80%81%E7%94%9F%E6%88%90-static-generation\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>静态生成 Static Generation</h5>\n<p><strong>静态生成</strong>是在项目打包部署时生成的页面，即打包完成后，页面内容是保持不变的。可以通过CDN进行缓存</p>\n<p>Next.js 默认情况下，页面都是静态生成的，若只是一个单纯的不需要额外数据的页面。写法与React组件基本相同</p>\n<p><strong>带有数据的静态渲染</strong></p>\n<p><strong>页面内容由额外数据决定</strong></p>\n<p>为了在打包时获取到额外数据，可以 导出一个异步函数<code>getStaticProps</code>,导出一个props对象供 React 组件使用</p>\n<pre><code><span>const</span> <span>Index</span> = (<span>data</span>) => {\n  <span>// {data.name}</span>\n}\n<span>export</span> <span>async</span> <span>function</span> <span>getStaticProps</span>(<span></span>) {\n  <span>let</span> data = {\n    <span>name</span>: <span>'John'</span>,\n  }\n  <span>return</span> {\n    <span>props</span>: data,\n  }\n}\n<span>export</span> <span>default</span> <span>Index</span></code></pre>\n<p><code>getStaticProps(context): ReturnObject</code> 打包时决定 React 可以使用的 <code>props</code>,不会在浏览器端代码出现（666）,并且只能在页面组件中使用这个函数，</p>\n<p>参数<code>context</code>由以下属性组成</p>\n<ul>\n<li><code>params</code>：动态路由情况下每个页面的<code>id</code>值在此生成</li>\n<li><code>preview</code>：判断页面是否处于预览模式。在部署之前跳过部署提前预览页面</li>\n<li><code>previewData</code>：通过<code>setPreviewData</code>返回的预览数据</li>\n<li><code>locale</code>：当前活动地区？</li>\n<li><code>locales</code>：所有支持的地区</li>\n<li><code>defaultLocale</code>：默认活动区域</li>\n</ul>\n<p>返回的<code>ReturnObject</code>应该包含以下元素</p>\n<ul>\n<li>\n<p><code>props</code>：必填项，React 组件接受的props对象。</p>\n</li>\n<li>\n<p><code>revalidate</code>：可选项，多少秒这个页面重新生成?</p>\n</li>\n<li>\n<p><code>notFound</code>：可选bool值，使页面返回 404 状态</p>\n</li>\n<li>\n<p><code>redirect</code>：可选项，用于跳转至另一个页面。格式如<code>{ destination: string, permanent: boolean}</code>，<code>destination</code>代表跳转的路径，<code>permanent</code>表明是否永久跳转？</p>\n<p>一个使用<code>notFound</code>和<code>redirect</code>的示例</p>\n<pre><code><span>export</span> <span>async</span> <span>function</span> <span>getStaticProps</span>(<span>context</span>) {\n  <span>const</span> res = <span>await</span> <span>fetch</span>(<span>`https://.../data`</span>)\n  <span>const</span> data = <span>await</span> res.<span>json</span>()\n  <span>if</span> (!data) {\n    <span>// </span>\n    <span>return</span> {\n      <span>notFound</span>: <span>true</span>,\n    }\n    <span>//</span>\n    <span>return</span> {\n      <span>redirect</span>:{\n        <span>destination</span>: <span>'/'</span>,\n        <span>permanent</span>: <span>false</span>,\n      }\n    }\n  }\n  <span>return</span> {\n    <span>props</span>: { data }\n  }\n}</code></pre>\n</li>\n</ul>\n<p><strong>页面路径由额外数据决定</strong></p>\n<p>Next.js提供了之前 Gatsby 才有的动态路由，这也是我放弃 Gatsby 的原因( GraphQL 搞不懂是另一个)。</p>\n<p>可以创建一个文件<code>pages/posts/[id].js</code>，根据传入的<code>id</code>决定展示哪个页面, 可以在<code>[id].js</code>导出一个异步方法<code>getStaticPaths</code>返回一个路径集合数组,类似<code>[{params:{id:1}},{params:{id:1}]</code>。再使用<code>getStaticProps(context)</code>中的<code>context.params.id</code>获取<code>id</code>动态生成内容</p>\n<pre><code><span>// [id].js</span>\n<span>const</span> <span>Post</span> = (<span>data</span>) => {\n  <span>// {data.contentHtml}</span>\n}\n\n<span>export</span> <span>async</span> <span>function</span> <span>getStaticPaths</span>(<span></span>){\n  <span>return</span> [\n    {<span>params</span>:{<span>id</span>:<span>1</span>}},\n    {<span>params</span>:{<span>id</span>:<span>1</span>}\n  ]\n}\n\n<span>export</span> <span>async</span> <span>function</span> <span>getStaticProps</span>(<span>context</span>){\n  <span>const</span> id = context?.<span>params</span>?.<span>id</span>\n  <span>const</span> data = <span>loadData</span>(id)\n  <span>return</span> {<span>props</span>: data}\n}\n\n<span>export</span> <span>default</span> <span>Post</span>;</code></pre>\n<p><code>getStaticPaths: ReturnObject</code>：打包前获取所有的动态路径</p>\n<p><code>ReturnObject</code> 包含属性</p>\n<ul>\n<li>\n<p><code>paths</code>：必填项，路径数组 <code>[{params:{id:'1'}},{params:{id:\"2\"}}]</code></p>\n<p><code>params</code>必须与 pages 文件夹 中的文件名称对应</p>\n<ul>\n<li>如果 page 文件名称是<code>pages/posts/[postId]/[commentId]</code>，<code>params</code>必须含有<code>postId</code>与<code>commentId</code></li>\n<li>如果使用类数组路由, page 文件名称是<code>pages/posts/[...slug]</code>，<code>params</code>必须包含一个<code>slug</code>的数组</li>\n<li>如果使用可选类数组路由，可以使用 <code>null</code>, <code>[]</code>, <code>undefined</code> 或 <code>false</code> 渲染根路由。例如，对于<code>pages/[[...slug]]</code>,如果<code>slug: false</code>,会渲染/页面</li>\n</ul>\n</li>\n<li>\n<p><code>fallback</code>必填项，访问路径不存在时的处理情况</p>\n<ul>\n<li><code>fallback: false</code>：如果当前访问路径不在<code>paths</code>对象中,访问404页面。每次添加新页面时，都需要重新打包</li>\n<li><code>fallback: true</code>：访问路径不在<code>paths</code>中不会导致404，Next.js 前端会创建一个<code>fallback</code>版本以供使用，在后端重新走一遍<code>getStaticPaths</code>，重新创建一个对应访问路径页面，并放到预渲染<code>paths</code>对象中以供以后使用</li>\n<li><code>fallback:blocking</code>：访问路径不在<code>paths</code>中不会导致404，Next.js 会通过服务端渲染</li>\n</ul>\n</li>\n<li>\n<p>Fallback pages</p>\n<p>在<code>fallback</code>版本时，<code>page</code>的<code>props</code>为空,如果使用<code>next/router</code>,<code>router.isFallback</code>是<code>true</code></p>\n<pre><code><span>const</span> <span>Post</span> = (<span>{ data }</span>) => {\n  <span>const</span> router = <span>useRouter</span>()\n  <span>if</span> (router.<span>isFallback</span>) {\n    <span>return</span> <span><span>&#x3C;<span>div</span>></span>Loading...<span>&#x3C;/<span>div</span>></span></span>\n  }\n  <span>return</span> <span><span>&#x3C;<span>div</span>></span>{data}page<span>&#x3C;/<span>div</span>></span></span>\n}\n<span>export</span> <span>async</span> <span>function</span> <span>getStaticPaths</span>(<span></span>) {\n  <span>return</span> {\n    <span>paths</span>: [\n      {\n        <span>params</span>: {\n          <span>id</span>: <span>'1'</span>,\n        },\n      },\n    ],\n    <span>fallback</span>: <span>true</span>,\n  }\n}\n<span>export</span> <span>async</span> <span>function</span> <span>getStaticProps</span>(<span>context</span>) {\n  <span>const</span> id = context.<span>params</span>.<span>id</span>\n  <span>return</span> {\n    <span>props</span>: {\n      <span>data</span>: id,\n    },\n    <span>revalidate</span>: <span>true</span>,\n  }\n}\n<span>export</span> <span>default</span> <span>Post</span></code></pre>\n</li>\n</ul>\n<h5 id=\"user-content-服务端渲染-server-side-rendering\"><a href=\"#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93-server-side-rendering\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>服务端渲染 Server-side Rendering</h5>\n<p><strong>服务端渲染</strong>在每个请求都会根据内容重新生成页面</p>\n<p>类似<code>getStaticProps</code>,可以使用<code>getServerSideProps</code>返回一个props对象,在每次请求时都会走一遍这个函数并重新生成页面</p>\n<pre><code><span>const</span> <span>Index</span> = (<span>data</span>) => {\n  <span>// {data.name}</span>\n}\n<span>export</span> <span>async</span> <span>function</span> <span>getServerSideProps</span>(<span></span>) {\n  <span>let</span> data = {\n    <span>name</span>: <span>'John'</span>,\n  }\n  <span>return</span> {\n    <span>props</span>: data,\n  }\n}\n<span>export</span> <span>default</span> <span>Index</span></code></pre>\n<p><code>getServerSideProps(context):ReturnObject</code>：用于服务端渲染的异步函数，返回一个props对象供 React 组件使用。同样的，不会在浏览器端代码出现该函数,并且只能在页面组件中使用这个函数，</p>\n<pre><code><span>export</span> <span>async</span> <span>function</span> <span>getServerSideProps</span>(<span>context</span>) {\n  <span>return</span> {\n    <span>props</span>: {},\n  }\n}</code></pre>\n<p><code>context</code>：包含以下属性</p>\n<ul>\n<li><code>params</code>：同<code>getStaticProps</code></li>\n<li><code>req</code>：请求对象</li>\n<li><code>res</code>：响应对象</li>\n<li><code>query</code>：query string 的对象</li>\n<li><code>preview</code>：同<code>getStaticProps</code></li>\n<li><code>previewData</code>：同<code>getStaticProps</code></li>\n<li><code>resolvedUrl</code>：请求URL的规范化版本</li>\n<li><code>locale</code>：同<code>getStaticProps</code></li>\n<li><code>locales</code>：同<code>getStaticProps</code></li>\n<li><code>defaultLocale</code>：同<code>getStaticProps</code></li>\n</ul>\n<p>ReturnObject包含以下属性：</p>\n<ul>\n<li><code>props</code>：同<code>getStaticProps</code></li>\n<li><code>notFound</code>：同<code>getStaticProps</code></li>\n<li><code>redirect</code>：同<code>getStaticProps</code></li>\n</ul>\n<h5 id=\"user-content-增量静态生成-incremental-static-regeneration-\"><a href=\"#%E5%A2%9E%E9%87%8F%E9%9D%99%E6%80%81%E7%94%9F%E6%88%90-incremental-static-regeneration-\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>增量静态生成 Incremental Static Regeneration ?</h5>\n<p>感觉像动态部署，部署时不会导致服务切断。返回时添加一个<code>revalidate: second</code>表明在几秒之后重新部署</p>\n<h3 id=\"user-content-样式集成\"><a href=\"#%E6%A0%B7%E5%BC%8F%E9%9B%86%E6%88%90\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>样式集成</h3>\n<h4 id=\"user-content-全局样式\"><a href=\"#%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>全局样式</h4>\n<p>创建文件<code>pages/_app.js</code>，在该文件中的样式会在所有页面和组件中生效</p>\n<pre><code><span>// _app.js</span>\n<span>import</span> <span>'../styles.css'</span>\n\n<span>// This default export is required in a new `pages/_app.js` file.</span>\n<span>export</span> <span>default</span> <span>function</span> <span>MyApp</span>(<span>{ Component, pageProps }</span>) {\n  <span>return</span> <span><span>&#x3C;<span>Component</span> {<span>...pageProps</span>} /></span></span>\n}</code></pre>\n<h4 id=\"user-content-范围样式\"><a href=\"#%E8%8C%83%E5%9B%B4%E6%A0%B7%E5%BC%8F\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>范围样式</h4>\n<p>Next.js 支持<a href=\"https://github.com/css-modules/css-modules\">CSS Modules</a> 为每个组件赋予独立的样式。命名为<code>[name].module.css</code>。会在每个<code>class</code>后添加一个 Hash 值</p>\n<h4 id=\"user-content-sass-支持\"><a href=\"#sass-%E6%94%AF%E6%8C%81\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>Sass 支持</h4>\n<p><code>npm install sass</code>即可在项目中使用 sass 或 scss</p>\n<p><strong>自定义 Sass 配置</strong></p>\n<p>可以通过在<code>next.config.js</code>中的<code>sassOptions</code>对 sass 进行配置</p>\n<pre><code><span>const</span> path = <span>require</span>(<span>'path'</span>)\n\n<span>module</span>.<span>exports</span> = {\n  <span>sassOptions</span>: {\n    <span>includePaths</span>: [path.<span>join</span>(__dirname, <span>'styles'</span>)],\n  },\n}</code></pre>\n<h4 id=\"user-content-css-in-js\"><a href=\"#css-in-js\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>CSS-in-JS</h4>\n<p>基本上和create-react-app一样，Next.js 内置了<a href=\"https://github.com/vercel/styled-jsx\">styled-jsx</a>。实现<a>styled-component</a>和<a href=\"https://emotion.sh/docs/introduction\">emotion</a>的效果</p>\n<h3 id=\"user-content-图形组件与优化\"><a href=\"#%E5%9B%BE%E5%BD%A2%E7%BB%84%E4%BB%B6%E4%B8%8E%E4%BC%98%E5%8C%96\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>图形组件与优化</h3>\n<p>Next.js 提供了与Gatsby一样优化很棒的图像组件<code>next/image</code>，<code>Image</code>支持常见的懒加载，resize，以现代格式显示图片等功能。</p>\n<h4 id=\"user-content-配置\"><a href=\"#%E9%85%8D%E7%BD%AE\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>配置</h4>\n<p>可以在<code>next.config.js</code>配置images获得最优化的效果</p>\n<p><strong>支持外部网站</strong></p>\n<p>加载一个外部网站托管的图片，在<code>next.config.js</code>中配置<code>images</code>的<code>domains</code>字段</p>\n<p><strong>自定义加载器</strong></p>\n<p>Next.js  可以自定义自己的图形加载器，通过配置<code>images</code>的<code>loader</code>字段</p>\n<p><strong>缓存</strong></p>\n<p>Next.js 默认会将访问过的图片缓存至<code>&#x3C;distDir>/cache/images</code>文件夹。缓存时间有服务端的<code>Cache-Control</code>字段控制：<code>s-maxage||max-age||60s</code></p>\n<pre><code><span>module</span>.<span>exports</span> = {\n  <span>images</span>: {\n    <span>// 外部域名</span>\n    <span>domains</span>: [<span>'example.com'</span>],\n    <span>// 自定义加载器</span>\n   \t<span>loader</span>: <span>'imgix'</span>,\n    <span>path</span>: <span>'https://example.com/myaccount/'</span>,\n  },\n}</code></pre>\n<h3 id=\"user-content-静态文件托管\"><a href=\"#%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E6%89%98%E7%AE%A1\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>静态文件托管</h3>\n<p><code>public</code>文件夹下的文件会作为 Next.js 的静态文件夹。可以通过URL<code>/</code>进行访问</p>\n<h2 id=\"user-content-路由\"><a href=\"#%E8%B7%AF%E7%94%B1\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>路由</h2>\n<p>正如上文所说，Next.js 在<code>pages</code>文件夹下的每个文件都是一个路由，路由名称与文件目录相同</p>\n<h4 id=\"user-content-路由规则\"><a href=\"#%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>路由规则</h4>\n<ul>\n<li><code>pages/index.js</code> → <code>/</code></li>\n<li><code>pages/blog/index.js</code> → <code>/blog</code></li>\n<li><code>pages/blog/first-post.js</code> → <code>/blog/first-post</code></li>\n<li><code>pages/dashboard/settings/username.js</code> → <code>/dashboard/settings/username</code></li>\n</ul>\n<p><strong>路由动态切片</strong></p>\n<p>可以使用大括号语法定义一个切片路由</p>\n<ul>\n<li><code>pages/blog/[slug].js</code> → <code>/blog/:slug</code> (<code>/blog/hello-world</code>)</li>\n<li><code>pages/[username]/settings.js</code> → <code>/:username/settings</code> (<code>/foo/settings</code>)</li>\n<li><code>pages/post/[...all].js</code> → <code>/post/*</code> (<code>/post/2020/id/title</code>)</li>\n</ul>\n<h3 id=\"user-content-动态路由\"><a href=\"#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>动态路由</h3>\n<p>在一些app中，比如博客系统，路由的路径很难预先定义，可以在pages文件夹下设置方括号定义动态路由，例如<code>pages/post/[id].js</code>, 会匹配任何类似<code>/post/1</code>,<code>/post/a</code>的路由</p>\n<pre><code><span>import</span> { useRouter } <span>from</span> <span>'next/router'</span>\n\n<span>const</span> <span>Post</span> = (<span></span>) => {\n  <span>const</span> router = <span>useRouter</span>()\n  <span>const</span> { pid } = router.<span>query</span>\n\n  <span>return</span> <span><span>&#x3C;<span>p</span>></span>Post: {pid}<span>&#x3C;/<span>p</span>></span></span>\n}\n\n<span>export</span> <span>default</span> <span>Post</span></code></pre>\n<h4 id=\"user-content-路由跳转\"><a href=\"#%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>路由跳转</h4>\n<p>通过<code>next/link</code>的<code>Link</code>组件,允许浏览器端跳转页面</p>\n<pre><code><span>import</span> <span>Link</span> <span>from</span> <span>'next/link'</span>\n<span>function</span> <span>Home</span>(<span></span>) {\n  <span>return</span> (\n    <span><span>&#x3C;></span>\n      <span>&#x3C;<span>Link</span> <span>href</span>=<span>\"/home\"</span>></span>\n        <span>&#x3C;<span>a</span>></span>Home<span>&#x3C;/<span>a</span>></span>\n      <span>&#x3C;/<span>Link</span>></span>\n    \t<span>&#x3C;<span>Link</span> <span>href</span>=<span>{</span>`/<span>blog</span>/${<span>encodeURIComponent</span>(<span>post.slug</span>)}`}></span>\n        <span>&#x3C;<span>a</span>></span>{post.title}<span>&#x3C;/<span>a</span>></span>\n\t\t\t<span>&#x3C;/<span>Link</span>></span>\n    // href 对象,pathname表明文件所在路径 \n      <span>&#x3C;<span>Link</span>\n        <span>href</span>=<span>{{</span>\n          <span>pathname:</span> '/<span>blog</span>/[<span>slug</span>]',\n          <span>query:</span> { <span>slug:</span> <span>post.slug</span> },\n        }}\n      ></span>\n        <span>&#x3C;<span>a</span>></span>{post.title}<span>&#x3C;/<span>a</span>></span>\n      <span>&#x3C;/<span>Link</span>></span>\n    <span>&#x3C;/></span></span>\n  )\n}</code></pre>\n<h4 id=\"user-content-捕获所有路由\"><a href=\"#%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E8%B7%AF%E7%94%B1\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>捕获所有路由</h4>\n<p>可以在方括号中添加拓展运算符<code>...</code>捕获所有路由</p>\n<p><code>pages/post/[...slug].js</code>匹配<code>/post/a</code>,<code>/post/a/b</code>。这种情况下, <code>router.query</code>的<code>slug</code>会是一个数组<code>['a','b']</code></p>\n<p><strong>Optional 捕获所有路由</strong></p>\n<p><code>pages</code>文件夹名称是双括号包裹的话，可以匹配根路由。<code>pages/post/[[...slug]].js</code>可以匹配<code>/post</code>,<code>/post/a</code>,<code>/post/a/b</code></p>\n<h4 id=\"user-content-路由注入\"><a href=\"#%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%85%A5\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>路由注入</h4>\n<p>使用<code>useRouter</code> hook进行路由注入,命令式的跳转路由</p>\n<pre><code><span>// post/aa&#x26;name=bb</span>\n<span>import</span> { useRouter } <span>from</span> <span>'next/router'</span>\n<span>const</span> router = <span>useRouter</span>()\n<span>const</span> { pid } = router.<span>query</span>\t<span>// {pid:'aa', name:'bb'}</span>\n&#x3C;span onClick={<span>() =></span> router.<span>push</span>(<span>'/about'</span>)}><span>Click</span> here to read more&#x3C;/span></code></pre>\n<h4 id=\"user-content-浅层路由\"><a href=\"#%E6%B5%85%E5%B1%82%E8%B7%AF%E7%94%B1\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>浅层路由</h4>\n<p>浅层路由允许你在不加载具体页面内容的前提下，修改路由。不知道有啥用</p>\n<pre><code><span>import</span> { useEffect } <span>from</span> <span>'react'</span>\n<span>import</span> { useRouter } <span>from</span> <span>'next/router'</span>\n<span>const</span> router = <span>useRouter</span>()\n<span>useEffect</span>(<span>() =></span> {\n   router.<span>push</span>(<span>'/?counter=10'</span>, <span>undefined</span>, { <span>shallow</span>: <span>true</span> })\n}, [])</code></pre>\n<h3 id=\"user-content-打包部署\"><a href=\"#%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>打包部署</h3>\n<h3 id=\"user-content-typescript集成\"><a href=\"#typescript%E9%9B%86%E6%88%90\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>TypeScript集成</h3>\n<p>创建<code>tsconfig.json</code>，<code>yarn add --dev typescript @types/react @types/node</code>即可在 Next.js 中使用 typescript</p>\n<h4 id=\"user-content-常见的渲染方法\"><a href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B8%B2%E6%9F%93%E6%96%B9%E6%B3%95\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>常见的渲染方法</h4>\n<pre><code><span>import</span> { <span>GetStaticProps</span>, <span>GetStaticPaths</span>, <span>GetServerSideProps</span> } <span>from</span> <span>'next'</span>\n\n<span>export</span> <span>const</span> <span>getStaticProps</span>: <span>GetStaticProps</span> = <span>async</span> (context) => {\n  <span>// ...</span>\n}\n\n<span>export</span> <span>const</span> <span>getStaticPaths</span>: <span>GetStaticPaths</span> = <span>async</span> () => {\n  <span>// ...</span>\n}\n\n<span>export</span> <span>const</span> <span>getServerSideProps</span>: <span>GetServerSideProps</span> = <span>async</span> (context) => {\n  <span>// ...</span>\n}</code></pre>\n<p>如果想要在 React 组件中的 props引用类型，可以使用<code>InferGetStaticPropsType&#x3C;typeof getStaticProps></code></p>\n<pre><code><span>import</span> { <span>InferGetStaticPropsType</span> } <span>from</span> <span>'next'</span>\n\n<span>type</span> <span>Post</span> = {\n  <span>author</span>: <span>string</span>\n  <span>content</span>: <span>string</span>\n}\n\n<span>// 这种情况就不需要使用 GetStaticProps，InferGetStaticPropsType 会自动生成 props 类型</span>\n<span>export</span> <span>const</span> <span>getStaticProps</span> = <span>async</span> (<span></span>) => {\n  <span>const</span> res = <span>await</span> <span>fetch</span>(<span>'https://.../posts'</span>)\n  <span>const</span> <span>posts</span>: <span>Post</span>[] = <span>await</span> res.<span>json</span>()\n\n  <span>return</span> {\n    <span>props</span>: {\n      posts,\n    },\n  }\n}\n\n<span>function</span> <span>Blog</span>(<span>{ posts }: InferGetStaticPropsType&#x3C;<span>typeof</span> getStaticProps></span>) {\n  <span>// will resolve posts to type Post[]</span>\n}\n\n<span>export</span> <span>default</span> <span>Blog</span></code></pre>\n<h4 id=\"user-content-api-路由\"><a href=\"#api-%E8%B7%AF%E7%94%B1\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>API 路由</h4>\n<p>在<code>pages/api</code>中可以自定义一些接口</p>\n<pre><code><span>import</span> <span>type</span> { <span>NextApiRequest</span>, <span>NextApiResponse</span> } <span>from</span> <span>'next'</span>\n\n<span>type</span> <span>Data</span> = {\n  <span>name</span>: <span>string</span>\n}\n\n<span>export</span> <span>default</span> (<span>req</span>: <span>NextApiRequest</span>, <span>res</span>: <span>NextApiResponse</span>&#x3C;<span>Data</span>>) => {\n  res.<span>status</span>(<span>200</span>).<span>json</span>({ <span>name</span>: <span>'John Doe'</span> })\n}</code></pre>\n<h4 id=\"user-content-custom-app\"><a href=\"#custom-app\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>Custom <code>App</code></h4>\n<p>比如在<code>_app.tsx</code>中自定义 App 组件</p>\n<pre><code><span>// import App from \"next/app\";</span>\n<span>import</span> <span>type</span> { <span>AppProps</span> <span>/*, AppContext */</span> } <span>from</span> <span>'next/app'</span>\n\n<span>function</span> <span>MyApp</span>(<span>{ Component, pageProps }: AppProps</span>) {\n  <span>return</span> <span><span>&#x3C;<span>Component</span> {<span>...pageProps</span>} /></span></span>\n}\n\n<span>// Only uncomment this method if you have blocking data requirements for</span>\n<span>// every single page in your application. This disables the ability to</span>\n<span>// perform automatic static optimization, causing every page in your app to</span>\n<span>// be server-side rendered.</span>\n<span>//</span>\n<span>// MyApp.getInitialProps = async (appContext: AppContext) => {</span>\n<span>//   // calls page's `getInitialProps` and fills `appProps.pageProps`</span>\n<span>//   const appProps = await App.getInitialProps(appContext);</span>\n\n<span>//   return { ...appProps }</span>\n<span>// }</span>\n\n<span>export</span> <span>default</span> <span>MyApp</span></code></pre>\n<h3 id=\"user-content-环境变量\"><a href=\"#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>环境变量</h3>\n<p>可以在项目根目录添加<code>.env/*</code>配置环境变量,其中<code>.env</code>和<code>.env.local</code>会作为默认配置，<code>.env.development</code>会作为开发环境的变量, <code>.env.production</code>会作为生产环境的变量设置</p>\n<p>环境变量中的变量可以通过<code>$</code>访问之前的变量</p>\n<p>环境变量只能被<code>node</code>环境使用,如果想在浏览器端使用环境变量，需要在变量名前添加<code>NEXT_PUBLIC_</code>前缀</p>\n<pre><code><span># .env</span>\nHOSTNAME=localhost\nPORT=8080\nHOST=http://<span>$HOSTNAME</span>:<span>$PORT</span>\nNEXT_PUBLIC_ANALYTICS_ID=abcdefghijk</code></pre>\n<h3 id=\"user-content-api-路由-1\"><a href=\"#api-%E8%B7%AF%E7%94%B1-1\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>API 路由</h3>\n<p><code>pages/api/*</code>中的文件会作为 api 接口而不是作为页面使用</p>\n<pre><code><span>// pages/api/hello</span>\n<span>export</span> <span>default</span> <span>function</span> <span>handler</span>(<span>req, res</span>) {\n  res.<span>status</span>(<span>200</span>).<span>json</span>({ <span>name</span>: <span>'John Doe'</span> })\n}</code></pre>\n<p>访问<code>/api/hello</code>会返回一个 json 字符串</p>\n<p>API 路由也支持像 <code>pages</code>那样的动态路由</p>\n<h4 id=\"user-content-api-中间件\"><a href=\"#api-%E4%B8%AD%E9%97%B4%E4%BB%B6\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>API 中间件</h4>\n<p>目前没有在 Next 中使用过</p>\n<h3 id=\"user-content-高级特性\"><a href=\"#%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>高级特性</h3>\n<h3 id=\"user-content-注意事项\"><a href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>注意事项</h3>\n<h4 id=\"user-content-读取文件使用processcwd\"><a href=\"#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8processcwd\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>读取文件使用<code>process.cwd()</code></h4>\n<p>Next.js编译代码是在一个独立的文件夹，所以不能使用<code>__dirname</code>获取文件夹目录,<code>process.cwd()</code>返回 Next.js 执行的目录</p>\n<h4 id=\"user-content-getstaticpaths-和-getserversideprops不能同时使用\"><a href=\"#getstaticpaths-%E5%92%8C-getserversideprops%E4%B8%8D%E8%83%BD%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a><code>getStaticPaths</code> 和 <code>getServerSideProps</code>不能同时使用</h4>\n","title":"学习笔记 Next.JS使用教程","date":"2021-04-23T13:47:05.000Z","tag":"React, Next.js","category":"程序人生","cover":null,"description":"description"}},"__N_SSG":true}