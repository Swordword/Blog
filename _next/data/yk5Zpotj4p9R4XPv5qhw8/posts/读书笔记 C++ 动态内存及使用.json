{"pageProps":{"postData":{"id":"读书笔记 C++ 动态内存及使用","contentHtml":"<h3 id=\"user-content-内存概述\"><a href=\"#%E5%86%85%E5%AD%98%E6%A6%82%E8%BF%B0\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>内存概述</h3>\n<p>C++内存大致分成三种：静态内存、栈内存和堆内存(又叫内存空间)。静态内存用于保存在整个函数运行期间都一直存在的对象，如局部static对象，类static数据成员。栈内存保存的是在程序运行中存在一段时间的对象，如函数中的非 static 对象。堆内存用来存储动态分配的对象，及在程序运行时(通过new这样的代码)分配的对象，因为动态对象是我们控制生成的，所以我们必须显示的销毁他们</p>\n<h3 id=\"user-content-动态内存与智能指针\"><a href=\"#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>动态内存与智能指针</h3>\n<p><code>new</code> 运算符在动态内存中为对象分配空间并返回一个指向该对象的指针；<code>delete</code> 运算符接受 <code>new</code> 出来的指针，销毁该对象，并释放与之关联的内存。</p>\n<p>想要在正确的时间释放内存是很困难的，并且也没发现好的调试内存泄漏的方法，C++ 提供了两种智能指针管理动态对象，<strong><code>shared_ptr</code> 允许多个指针指向同一个对象</strong>，<strong><code>unique_ptr</code> 每个指针和一个对象绑定</strong>。</p>\n<h4 id=\"user-content-智能指针-shared_ptr\"><a href=\"#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-shared_ptr\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>智能指针 <code>shared_ptr</code></h4>\n<ol>\n<li>\n<p>是个模版，所以也需要尖括号指明类型。<code>shared_ptr&#x3C;int> pi</code></p>\n<p>定义和改变<code>shared_ptr</code> 的其他方法</p>\n<p>| 定义                                           | 说明                           |\n| ---------------------------------------------- | ------------------------------ |\n| shared_ptr  p(q) 、shared_ptr  p(u)      | p管理内置指针q所指向的对象     |\n| shared_ptr  p(q, d)、shared_ptr  p(q, d) | 使用可调用对象代替默认的delete |</p>\n</li>\n<li>\n<p>智能指针的使用与普通指针类似。 <code>if(pi &#x26;&#x26; pi->empty()) *pi = 11;</code></p>\n</li>\n<li>\n<p><code>pi.get()</code>返回 pi 保存的指针，<code>swap(p,q)</code> 交换p和q的指针</p>\n</li>\n<li>\n<p><code>make_shared&#x3C;T>(arg)</code> 返回一个 shared_ptr，指向类型为T的对象，其中arg是该对象初始化的参数</p>\n<p>如 <code>shared_ptr&#x3C;int> p = make_shared&#x3C;int>(42);</code> <code>shared_ptr&#x3C;string> q = make_shared&#x3C;string>(10,'9');</code></p>\n<p><code>make_shared&#x3C;T>p(q)</code> p 是 shared_ptr q 的拷贝，该操作会递增 q 中的计数器，q 的指针必须能转换为T*</p>\n</li>\n<li>\n<p>智能指针相较于动态内存的优势在于当指向该对象的最后一个 shared_ptr 被销毁时（ shared_ptr 使用的计数器由1转为0），shared_ptr会自动销毁该对象(通过类中的成员函数：析构函数)。其中判断是不是最后一个智能指针是通过shared_ptr关联的<strong>引用计数</strong>完成的。</p>\n</li>\n<li>\n<p>引用计数的计算方式</p>\n<p>查看当前智能指针的计数器可以通过 <code>pi.use_count()</code>方法，</p>\n<p>或者根据自己的经验。当我们试图拷贝一个shared_ptr 时，计数器就会递增，反之则递减。智能指针常见的拷贝情形如下</p>\n<ul>\n<li>用一个新 shared_ptr 初始化shared_ptr</li>\n<li>将 shared_ptr 作为参数传递给一个函数</li>\n<li>将 shared_ptr 作为函数的返回值</li>\n</ul>\n</li>\n</ol>\n<p>为什么要使用动态内存？</p>\n<ol>\n<li>程序不知道自己未来需要使用多少对象，如之前使用的容器类</li>\n<li>程序不知道所需对象的准确类型</li>\n<li>程序需要在多个对象见共享数据，即多个对象共享相同的状态，a销毁了，b紧连着也会被销毁</li>\n</ol>\n<h4 id=\"user-content-通过new和delete直接管理内存\"><a href=\"#%E9%80%9A%E8%BF%87new%E5%92%8Cdelete%E7%9B%B4%E6%8E%A5%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>通过<code>new</code>和<code>delete</code>直接管理内存</h4>\n<p>在自由空间分配的内存是<strong>无名</strong>的，<code>new</code>返回一个指向该对象的指针</p>\n<p><strong><code>new</code>初始化：</strong></p>\n<ol>\n<li>默认初始化\t<code>string *ps = new string()</code></li>\n<li>传统的构造方式（使用括号）  <code>string *ps = new string(10 , '9')</code></li>\n<li>列表初始化  <code>vector&#x3C;int> *v = new vector&#x3C;int>{0,1,2,3}</code></li>\n<li>对动态分配的值进行初始化    <code>string *ps = new string()</code></li>\n</ol>\n<p><strong>动态分配的 const 对象：</strong></p>\n<p><code>const int *pci = new const int(1024)</code> 必须初始化返回一个指向const的指针</p>\n<p><strong>防止内存耗尽抛出的异常：</strong></p>\n<p>如果程序用光了可用的自由空间，<code>new</code> 默认会抛出类型为<code>bad_alloc</code>的异常，可以通过使用**定位<code>new</code>**的方式组织抛出异常</p>\n<p><code>int *p1 = new int</code> \t// 分配失败，抛出<code>bad_alloc</code></p>\n<p><code>int *p1 = new (nothrow) int</code> // 分配失败，返回一个空指针</p>\n<p><strong>释放动态内存</strong>：</p>\n<p>传递给<code>delete</code> 通过<code>new</code>获得的指针：销毁给定的指针指向的对象；释放对应的内存，<strong>有内置指针new管理的动态内存在显示释放之前都会一直存在</strong></p>\n<p><strong>动态内存管理常见问题：</strong></p>\n<ol>\n<li>\n<p>忘记<code>delete</code>内存，导致<strong>内存泄漏</strong></p>\n</li>\n<li>\n<p>使用已经释放过的内存。可以通过释放内存后将指针置为空来解决</p>\n<p>但是只能解决单一的指针，若多个指针指向同一个对象，就会导致别的指针无效</p>\n<pre><code><span><span>int</span> *<span>p</span><span>(<span>new</span> <span>int</span>(<span>42</span>))</span></span>;\t<span>// p指向动态内存</span>\n<span>auto</span> q = p;\t\t<span>// p和q指向相同的内存</span>\n<span>delete</span> p;\t\t<span>// p和q均无效</span>\np = <span>nullptr</span>;\t<span>// 置空p，但是！q依然是一个指针，却无效了</span></code></pre>\n</li>\n<li>\n<p>对同一块内存释放两次。</p>\n</li>\n</ol>\n<p>**空悬指针：**指向一块曾经保存数据对象但是现在已经无效的内存的指针</p>\n<p>当<code>delete</code>掉一个指针后，指针值就变为无效。但是很多机器仍然保存着（已经释放了的）动态内存的地址。导致 这个指针可能依然保存之前的值，但是它之后会变成什么样子已经不是你自己能控制的了，就像你把房子卖给了别人，下次再到这个地址看看，可能还是你的房子，也可能已经被改成公共厕所了。这种指针就叫做空悬指针</p>\n<h4 id=\"user-content-shared_ptr和new结合使用\"><a href=\"#shared_ptr%E5%92%8Cnew%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a><code>shared_ptr</code>和<code>new</code>结合使用</h4>\n<p>接受指针参数的智能指针构造函数是explicit的（无法将内置指针隐式转换为一个智能指针），因此必须直接初始化一个智能指针</p>\n<p><code>shared_ptr&#x3C;int> p1 = new int(1024)</code> \t// 错误 打算将 <code>new</code> 内置指针转换为智能指针</p>\n<p><code>shared_ptr&#x3C;int> p1(new int(1024))</code></p>\n<p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象。但是，如果我们<strong>提供自己的delete操作</strong>，我们<strong>可以将智能指针绑定到一个指向其他类型的资源的指针上</strong></p>\n<p><strong>不要混合使用普通指针和智能指针</strong></p>\n<pre><code><span><span>void</span> <span>process</span><span>(shared_ptr&#x3C;<span>int</span>> ptr)</span></span>{\n} <span>// ptr 离开作用域，被销毁</span>\n\n<span><span>int</span> *<span>x</span><span>(<span>new</span> <span>int</span>(<span>1024</span>))</span></span>; <span>// x 是一个普通指针，而不是一个智能指针</span>\n<span>process</span>(x);\t<span>// error shared_ptr 是explicit的</span>\n<span>process</span>(<span>shared_ptr</span>&#x3C;<span>int</span>>(x))\t<span>// 合法！但是 x 的内存会被释放，导致下一行的j获取不到值</span>\n<span>int</span> j = *x;</code></pre>\n<p><strong>不要使用get函数返回值初始化另一个智能指针或为指针指针赋值：</strong></p>\n<p>智能指针的<code>get</code>函数返回一个内置指针，指向智能指针管理的对象。</p>\n<p><code>get</code> 用来将指针的访问权限传递给代码，即只有在确保代码不会delete指针时，才能使用<code>get</code></p>\n<pre><code><span>shared_ptr&#x3C;<span>int</span>> <span>p</span><span>(<span>new</span> <span>int</span>(<span>42</span>))</span></span>;\n<span>int</span> *q = p.<span>get</span>();\n{\n\t<span>shared_ptr</span>&#x3C;<span>int</span>>(q);\n} <span>// 程序结束，q被销毁，指向的内存被释放，p为空悬指针</span>\n<span>int</span> foo = *p;</code></pre>\n<p><strong>shared_ptr 其他操作：</strong></p>\n<p><code>shared_ptr.reset()</code> 将新指针赋予原先智能指针</p>\n<p><code>shared_ptr.unique()</code> 检查自己是不是当前对象仅有的用户，即计数器是1</p>\n<h4 id=\"user-content-使用智能指针优化程序异常\"><a href=\"#%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E5%BC%82%E5%B8%B8\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>使用智能指针优化程序异常</h4>\n<p>异常发生后，析构函数可能不会正常运行，使用智能指针，即使程序块提前结束，也会将多余的内存释放。</p>\n<p><strong>智能指针使用规范：</strong></p>\n<ul>\n<li>不使用相同的内置指针初始化（或reset）多个智能指针</li>\n<li>不delete get() 返回的指针</li>\n<li>不使用get() 初始化或reset 另一个智能指针</li>\n<li>使用 get() 返回的指针，当最后一个智能指针销毁时，内置指针成为悬空指针</li>\n<li>当智能指针管理的不是new分配的内存，需要传递给一个删除器</li>\n</ul>\n<h4 id=\"user-content-unique_ptr使用\"><a href=\"#unique_ptr%E4%BD%BF%E7%94%A8\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>unique_ptr使用</h4>\n<p><code>unique_ptr</code> 与 给定对象一一对应， 因此不支持普通的拷贝和赋值操作</p>\n<p>通过绑定到一个<code>new</code>返回的指针初始化， 没有类似 make_shared 的方法</p>\n<p>可以通过调用<code>release</code> 或<code> reset</code> 将指针的所有权从 一个 <code>unique_ptr</code> 转移给另一个 <code>unique_ptr</code></p>\n<pre><code><span>unique_ptr&#x3C;string> <span>p1</span> <span>(<span>new</span> string(<span>\"Hello\"</span>))</span></span>;\n<span>unique_ptr&#x3C;string> <span>p2</span><span>(p1.release())</span></span>; <span>// 将所有权p1转向p2， release将 p1 置为空</span>\n<span>unique_ptr&#x3C;string> <span>p3</span><span>(<span>new</span> string(<span>\"world\"</span>))</span>\np2.<span>reset</span><span>(p3.release())</span> <span>// reset 释放了原来 p2 指向的内存</span></span></code></pre>\n<p><code>release</code>返回当前保存的指针并将其置为空。</p>\n<p><code>reset</code>接受一个可选的指针参数，令<code>uniqeu_ptr</code>重新指向给定的指针。</p>\n<p><strong>可以拷贝或赋值一个将要被销毁的unique_ptr</strong>. 例如从函数中返回一个<code>unique_ptr</code></p>\n<pre><code><span>unique_ptr&#x3C;<span>int</span>> <span>clone</span><span>(<span>int</span> p)</span></span>{\n  <span>return</span> <span>unique_ptr</span>&#x3C;<span>int</span>>(<span>new</span> <span>int</span>(p))\n}</code></pre>\n<p><strong>向 unique_ptr 传递删除器</strong></p>\n<p>重载一个 unique_ptr 的删除器会影响到 unique_ptr类型并且决定如何构造该类型的对象，删除器必须在<strong>尖括号中指向类型之后提供删除器类型</strong></p>\n<p><code>unique_ptr&#x3C;objT,delT p(new objT, fcn)>;</code></p>\n<h4 id=\"user-content-weak_ptr\"><a href=\"#weak_ptr\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>weak_ptr</h4>\n<p><code>weak_ptr</code> ：不控制所指向对象生存期的智能指针\n指向一个<code>shared_ptr</code>管理的对象，当其绑定到一个<code>shared_ptr</code> 上时，不会改变<code>shared_ptr</code>的引用计数.</p>\n<p>| API               | 说明                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| weak_ptr w     | 空 weak_ptr，指向类型为T的对象                               |\n| weak_ptr w(sp) | 与shared_ptr sp指向相同对象的weak_ptr. T可以转换为sp指向的类型 |\n| w=p               | p可以是一个shared_ptr 或者 weak_ptr，w与p共享家对象          |\n| w.reset()         | 将w置为空                                                    |\n| w.use_count()     | 与w共享的shared_ptr 的计数器数量                             |\n| w.expired()       | 若 w.use_count() 为0， 返回true。反之返回 false              |\n| w.lock()          | 若 expired 为 true，返回一个空的shared_ptr,否则返回指向w的对象的 shared_ptr |</p>\n<p>由于<code>weak_ptr</code> 指向的对象可能不存在，所以必须在使用前使用<code>wp.lock()</code>判断 weak_ptr 指向的对象是否存在</p>\n<p><code>if(shared_ptr&#x3C;int> np = wp.lock()){}\t// 如果np不为空则条件成立，wp对应了一个shared_ptr对象</code></p>\n<p><code>weak_ptr</code>可以用来解决循环队列 <code>shared_ptr</code> 循环引用的问题。</p>\n","title":"读书笔记 C++ 动态内存及使用","date":"2021-03-25T13:39:08.000Z","description":"C++通过new动态分配内存","tag":"Cpp"}},"__N_SSG":true}