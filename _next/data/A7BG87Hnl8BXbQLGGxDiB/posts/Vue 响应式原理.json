{"pageProps":{"postData":{"id":"Vue 响应式原理","contentHtml":"<h2 id=\"user-content-背景\"><a href=\"#%E8%83%8C%E6%99%AF\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>背景</h2>\n<p>vue的响应式更新是vue的一大特点</p>\n<p>响应式原理一般包括以下几个部分</p>\n<ul>\n<li>通过数据劫持/数据代理：用于侦测数据的变化</li>\n<li>依赖收集：收集视图用来了哪些数据</li>\n<li>发布订阅模式：当数据发生变化时，自动通知需要更新的视图，进行更新</li>\n</ul>\n<h2 id=\"user-content-准备\"><a href=\"#%E5%87%86%E5%A4%87\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>准备</h2>\n<pre><code><span>class</span> <span>Vue</span> {\n  <span>constructor</span>(<span>options</span>) {\n    <span>let</span> data = (<span>this</span>.<span>_data</span> = options.<span>data</span>)\n    <span>observe</span>(data)\n\t}\n}\n<span>let</span> vue = <span>new</span> <span>Vue</span>({\n  <span>data</span>: {\n    <span>name</span>: <span>'Bob'</span>,\n  },\n})\n<span>setTimeout</span>(<span>() =></span> {\n  vue.<span>_data</span>.<span>name</span> = <span>'Alice'</span>\n}, <span>1000</span>)</code></pre>\n<h2 id=\"user-content-数据劫持\"><a href=\"#%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>数据劫持</h2>\n<p>vue2.x的数据劫持使用的是<code>Object.defineProperty</code>,其不能对数组和特殊对象进行监听，因此Vue3.x使用的<code>Proxy</code>则解决了这个问题</p>\n<pre><code><span>function</span> <span>observe</span>(<span>obj</span>){\n  <span>if</span>(!obj|| <span>typeof</span> obj ===<span>'object'</span>) <span>return</span>\n  <span>Object</span>.<span>keys</span>(obj).<span>forEach</span>(<span><span>key</span>=></span>{\n    <span>// 劫持obj的每个属性</span>\n    <span>defineReactive</span>(obj,key,obj[key])\n  })\n}\n<span>function</span> <span>defineReactive</span>(<span>obj,key,val</span>){\n  <span>// 如果 val 是一个对象，则需要深度遍历该对象</span>\n  <span>observe</span>(val)  \n  <span>Object</span>.<span>defineProperty</span>(obj,key,{\n    <span>configureble</span>: <span>true</span>,\t<span>// 可删除</span>\n    <span>enumrable</span>: <span>true</span>,\t<span>// 可遍历</span>\n    <span>get</span>(<span></span>){\n      <span>return</span> val;\n    },\n    <span>set</span>(<span>newVal</span>){\n      <span>if</span> (val === newVal) <span>return</span>\n      val = newVal\n      <span>// 如果设置的是一个新的对象，也需要劫持这个对象</span>\n      <span>observe</span>(newVal)\n    }\n\t})\n}</code></pre>\n<h3 id=\"user-content-vue3x使用的proxy有何优势\"><a href=\"#vue3x%E4%BD%BF%E7%94%A8%E7%9A%84proxy%E6%9C%89%E4%BD%95%E4%BC%98%E5%8A%BF\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>Vue3.x使用的Proxy有何优势</h3>\n<ul>\n<li>\n<p>proxy对于数组的变化也能监听到</p>\n</li>\n<li>\n<p>不需要想defineProperty进行深度遍历监听</p>\n</li>\n</ul>\n<pre><code><span>class</span> <span>Vue</span> {\n  <span>constructor</span>(<span>options</span>) {\n    <span>this</span>.<span>_data</span> = options.<span>data</span>\n    <span>this</span>.<span>_data</span> = <span>observe</span>(options.<span>data</span>)\n  }\n}\n<span>function</span> <span>observe</span>(<span>obj</span>) {\n  <span>let</span> dep = <span>new</span> <span>Dep</span>()\n  <span>return</span> <span>new</span> <span>Proxy</span>(obj, {\n    <span>get</span>(<span>obj, prop</span>) {\n      <span>return</span> obj[prop]\n    },\n    <span>set</span>(<span>obj, props, newVal</span>) {\n      <span>if</span> (obj[props] === newVal) <span>return</span>\n      obj[props] = newVal\n    },\n  })\n}</code></pre>\n<h2 id=\"user-content-依赖收集\"><a href=\"#%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>依赖收集</h2>\n<p>依赖收集是一个队列，如果视图使用了监听的data，则创建一个新的 Wactcher，将其 push 到依赖收集的队列中</p>\n<pre><code><span>class</span> <span>Dep</span> {\n  <span>static</span> target = <span>null</span>\n  subs = []\n  <span>addSub</span>(<span>sub</span>) {\n    <span>// sub 是一个 Wacther 实例</span>\n    <span>this</span>.<span>subs</span>.<span>push</span>(sub)\n  }\n  <span>notify</span>(<span></span>) {\n    <span>this</span>.<span>subs</span>.<span>forEach</span>(<span>(<span>watcher</span>) =></span> watcher.<span>update</span>())\n  }\n}</code></pre>\n<h2 id=\"user-content-发布订阅\"><a href=\"#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>发布订阅</h2>\n<p>发布订阅其实内部储存了一个用于更新视图的 callback 函数，放在依赖收集的队列中，当 data 的属性发生变化时，依赖收集队列中的每个 wacther都会调用 update 函数，从而触发视图更新</p>\n<pre><code><span>class</span> <span>Wacther</span>{\n  <span>// vm 时 Vue 的实例</span>\n  <span>constructor</span>(<span>vm,exp,cb</span>){\n    <span>Dep</span>.<span>target</span> = <span>this</span>\n    <span>this</span>.<span>vm</span> = vm\n    <span>this</span>.<span>exp</span> = exp\n    <span>this</span>.<span>cb</span> = cb\n    <span>// vm._data.a，从而触发 data.get 方法，在 dep 中 push 这个 Dep.target（即这个watcher）</span>\n    <span>let</span> arr = exp.<span>split</span>(<span>'.'</span>)\n    <span>let</span> val = vm\n    arr.<span>forEach</span>(<span><span>key</span>=></span>{\n      val = val[key]\n    })\n    <span>Dep</span>.<span>target</span> = <span>null</span>\n  }\n}</code></pre>\n<h2 id=\"user-content-更新-数据劫持的函数\"><a href=\"#%E6%9B%B4%E6%96%B0-%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E7%9A%84%E5%87%BD%E6%95%B0\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>更新 数据劫持的函数</h2>\n<p>现在有了依赖收集的队列和生成发布订阅的构造函数，我们需要更新一下 observe 函数来使用这个 dep 队列和 wacther 实例</p>\n<pre><code>...\n<span>function</span> <span>defineReactive</span>(<span>obj,key,val</span>){\n  <span>// 如果 val 是一个对象，则需要深度遍历该对象</span>\n  <span>observe</span>(val)  \n+  <span>// 实例化一个依赖收集队列，里面存放的订阅实例 Watcher</span>\n+  <span>let</span> dep = <span>new</span> <span>Dep</span>()\n  <span>Object</span>.<span>defineProperty</span>(obj, key,{\n    <span>configureble</span>: <span>true</span>,\t<span>// 可删除</span>\n    <span>enumrable</span>: <span>true</span>,\t<span>// 可遍历</span>\n    <span>get</span>(<span></span>){\n+     <span>// Dep.target 是 Wacther，见之后的 Wactcher 的构造函数</span>\n+      <span>Dep</span>.<span>target</span> &#x26;&#x26; dep.<span>addSub</span>(<span>Dep</span>.<span>target</span>)\n      <span>return</span> val;\n    },\n    <span>set</span>(<span>newVal</span>){\n      <span>if</span> (val === newVal) <span>return</span>\n      val = newVal\n      <span>// 如果设置的是一个新的对象，也需要劫持这个对象</span>\n      <span>observe</span>(newVal)\n+      <span>// 当设置新值时,触发 Wacther 中 update 函数，对视图进行更新</span>\n+      dep.<span>notify</span>()\n    }\n\t})\n}</code></pre>\n<p>使用 proxy与法 与上述相同</p>\n<h2 id=\"user-content-总结\"><a href=\"#%E6%80%BB%E7%BB%93\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>总结</h2>\n<p>完整的实例如下</p>\n<pre><code><span>class</span> <span>Vue</span> {\n  <span>constructor</span>(<span>options</span>) {\n    <span>let</span> data = (<span>this</span>.<span>_data</span> = options.<span>data</span>)\n    <span>observe</span>(data)\n  }\n}\n\n<span>function</span> <span>observe</span>(<span>obj</span>) {\n  <span>if</span> (!obj || <span>typeof</span> obj !== <span>'object'</span>) <span>return</span>\n  <span>Object</span>.<span>keys</span>(obj).<span>forEach</span>(<span>(<span>key</span>) =></span> <span>defineReactive</span>(obj, key, obj[key]))\n  <span>function</span> <span>defineReactive</span>(<span>obj, key, val</span>) {\n    <span>observe</span>(val)\n    <span>let</span> dep = <span>new</span> <span>Dep</span>()\n    <span>Object</span>.<span>defineProperty</span>(obj, key, {\n      <span>configurable</span>: <span>true</span>,\n      <span>enumerable</span>: <span>true</span>,\n      <span>get</span>(<span></span>) {\n        <span>Dep</span>.<span>target</span> &#x26;&#x26; dep.<span>addSub</span>(<span>Dep</span>.<span>target</span>)\n        <span>return</span> val\n      },\n      <span>set</span>(<span>newVal</span>) {\n        <span>if</span> (val === newVal) <span>return</span>\n        val = newVal\n        dep.<span>notify</span>()\n        <span>observe</span>(newVal)\n      },\n    })\n  }\n}\n\n<span>class</span> <span>Dep</span> {\n  <span>static</span> target = <span>null</span>\n  subs = []\n  <span>addSub</span>(<span>sub</span>) {\n    <span>this</span>.<span>subs</span>.<span>push</span>(sub)\n  }\n  <span>notify</span>(<span></span>) {\n    <span>this</span>.<span>subs</span>.<span>forEach</span>(<span>(<span>sub</span>) =></span> sub.<span>update</span>())\n  }\n}\n\n<span>class</span> <span>Watcher</span> {\n  <span>constructor</span>(<span>vm, exp, cb</span>) {\n    <span>this</span>.<span>vm</span> = vm\n    <span>this</span>.<span>exp</span> = exp\n    <span>this</span>.<span>cb</span> = cb\n    <span>Dep</span>.<span>target</span> = <span>this</span>\n    <span>let</span> val = vm.<span>_data</span>\n    exp.<span>split</span>(<span>'.'</span>).<span>forEach</span>(<span>(<span>key</span>) =></span> {\n      val = val[key]\n    })\n    <span>Dep</span>.<span>target</span> = <span>null</span>\n  }\n  <span>update</span>(<span></span>) {\n    <span>let</span> val = <span>this</span>.<span>vm</span>.<span>_data</span>\n    <span>this</span>.<span>exp</span>.<span>split</span>(<span>'.'</span>).<span>forEach</span>(<span>(<span>key</span>) =></span> {\n      val = val[key]\n    })\n    <span>this</span>.<span>cb</span>(val)\n  }\n}\n\n<span>let</span> vue = <span>new</span> <span>Vue</span>({\n  <span>data</span>: {\n    <span>name</span>: <span>'Bob'</span>,\n  },\n})\n\n<span>// 手动添加一个 watcher，实际情况下，模版渲染时自动生成订阅函数</span>\n<span>new</span> <span>Watcher</span>(vue, <span>'name'</span>, <span>(<span>newVal</span>) =></span> {\n  <span>console</span>.<span>log</span>(<span>'render'</span>, newVal)\n})\n\n<span>setTimeout</span>(<span>() =></span> {\n  vue.<span>_data</span>.<span>name</span> = <span>'Alice'</span>\n}, <span>1000</span>)</code></pre>\n<h2 id=\"user-content-参考\"><a href=\"#%E5%8F%82%E8%80%83\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>参考</h2>\n<p><a href=\"https://cn.vuejs.org/v2/guide/reactivity.html\">深入响应式原理 — Vue.js (vuejs.org)</a></p>\n<p><a href=\"https://juejin.cn/post/6844903586103558158\">不好意思！耽误你的十分钟，让MVVM原理还给你 (juejin.cn)</a></p>\n<p><a href=\"https://juejin.cn/book/6844733705089449991/section/6844733705228025869\">剖析 Vue.js 内部运行机制 - 染陌同学 - 掘金小册 (juejin.cn)</a></p>\n<p><a href=\"https://ustbhuangyi.github.io/vue-analysis/v2/reactive/reactive-object.html\">响应式对象 | Vue.js 技术揭秘 (ustbhuangyi.github.io)</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy - JavaScript | MDN (mozilla.org)</a></p>\n","title":"Vue 响应式原理","date":"2019-06-29T13:45:05.000Z","description":"vue2.x的监听绑定使用的是`Object.defineProperty`,不能对数组和特殊对象进行监听，而`Proxy`则解决了这个问题","tag":"JavaScript,Vue,Reactive"}},"__N_SSG":true}