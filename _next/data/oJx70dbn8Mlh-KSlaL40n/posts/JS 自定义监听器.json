{"pageProps":{"postData":{"id":"JS 自定义监听器","contentHtml":"<p>js中的自定义监听器分为浏览器DOM端、Node端，最后可以自己实现一个自定义监听器</p>\n<h3 id=\"user-content-浏览器端\"><a href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>浏览器端</h3>\n<p>浏览器端的自定义监听器可以通过原生的**<code>Event</code><strong>和</strong><code>CustomEvent</code>**构造函数实现</p>\n<p>**<code>Event</code>**语法 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Event/Event\">基础</a></p>\n<p><strong><code>CustomEvent</code></strong><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/CustomEvent\">基础</a></p>\n<p><code>CustomEvent</code>相比<code>Event</code>的优势是有个<code>detail</code>字段可以为事件传入自定义参数</p>\n<p>举例使用</p>\n<p>在两个独立的模块：商品购买，购物车中，可以在购买页面定义一个自定义监听器 <strong>BuyEvent</strong>，再在其他模块中监听该事件。当用户购买商品时，通过<code>dispatchEvent</code>触发该事件</p>\n<p><strong>buy模块</strong></p>\n<pre><code><span>// btnElem 购买按钮\t</span>\nbtnElem.<span>addEventListener</span>(<span>'click'</span>, <span>(<span>e</span>) =></span> {\n  <span>// goodInfo 商品信息</span>\n  <span>const</span> buyEvent = <span>new</span> <span>CustomEvent</span>(<span>'buyEvent'</span>, {\n    <span>detail</span>: goodInfo,\n  })\n  <span>document</span>.<span>dispatchEvent</span>(buyEvent)\n})</code></pre>\n<p><strong>购物车模块</strong></p>\n<pre><code><span>document</span>.<span>addEventListener</span>(<span>'buyEvent'</span>, <span>(<span>e</span>) =></span> {\n  <span>console</span>.<span>log</span>(<span>`商品模块get，<span>${e.detail}</span>`</span>)\n})</code></pre>\n<h3 id=\"user-content-node端\"><a href=\"#node%E7%AB%AF\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>Node端</h3>\n<p>Node端自带了<strong>event</strong>模块可以实现监听器功能</p>\n<pre><code><span>const</span> <span>EventEmitter</span> = <span>require</span>(<span>'events'</span>)\n\n<span>const</span> myEvent = <span>new</span> <span>EventEmitter</span>()\n\nmyEvent.<span>on</span>(<span>'mEvent'</span>, <span>(<span>data</span>) =></span> {\n  <span>console</span>.<span>log</span>(data)\n})\n\nmyEvent.<span>emit</span>(<span>'mEvent'</span>, <span>'发射！！！'</span>)\n</code></pre>\n<h3 id=\"user-content-自定义事件监听器\"><a href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>自定义事件监听器</h3>\n<p>可以自己实现一个自定义监听器实现上述功能</p>\n<pre><code><span>class</span> <span>EventEmiter</span> {\n  <span>constructor</span>(<span></span>) {\n    <span>this</span>.<span>events</span> = []\n  }\n  <span>on</span>(<span>event, cb</span>) {\n    <span>console</span>.<span>log</span>(<span>'this.events'</span>, <span>this</span>.<span>events</span>)\n    <span>if</span> (<span>this</span>.<span>events</span>[event]) {\n      <span>this</span>.<span>events</span>[event].<span>push</span>(cb)\n    } <span>else</span> {\n      <span>this</span>.<span>events</span>[event] = [cb]\n    }\n  }\n  <span>emit</span>(<span>event</span>) {\n    <span>const</span> cbList = <span>this</span>.<span>events</span>[event]\n    <span>if</span> (!cbList) {\n      <span>console</span>.<span>error</span>(<span>'你注册了事件嘛QAQ'</span>)\n      <span>return</span>\n    }\n    <span>let</span> args = <span>Array</span>.<span>from</span>(<span>arguments</span>).<span>slice</span>(<span>1</span>)\n    cbList.<span>forEach</span>(<span>(<span>cb</span>) =></span> {\n      cb.<span>apply</span>(<span>this</span>, args)\n    })\n  }\n}\n\n<span>let</span> mEvent = <span>new</span> <span>EventEmiter</span>()\nmEvent.<span>on</span>(<span>'mEvent'</span>, <span>(<span>data</span>) =></span> {\n  <span>console</span>.<span>log</span>(<span>'got it'</span>, data)\n})\n<span>setTimeout</span>(<span>() =></span> {\n  mEvent.<span>emit</span>(<span>'mEvent'</span>, <span>'发射！！！'</span>)\n}, <span>2000</span>)\n</code></pre>\n<p>当然，如果你不想用<code>class</code>的话，用函数也可以实现（PS，这个世界越来越奇怪了，JS在向class靠，而C++却在惦记着函数式编程。。。）</p>\n<pre><code><span>function</span> <span>EventEmiter</span>(<span></span>) {}\n<span>EventEmiter</span>.<span><span>prototype</span></span>.<span>events</span> = {}\n<span>EventEmiter</span>.<span><span>prototype</span></span>.<span>on</span> = <span>function</span> (<span>event, cb</span>) {\n  <span>console</span>.<span>log</span>(<span>'this.events'</span>, <span>this</span>.<span>events</span>)\n  <span>if</span> (<span>this</span>.<span>events</span>[event]) {\n    <span>this</span>.<span>events</span>[event].<span>push</span>(cb)\n  } <span>else</span> {\n    <span>this</span>.<span>events</span>[event] = [cb]\n  }\n}\n<span>EventEmiter</span>.<span><span>prototype</span></span>.<span>emit</span> = <span>function</span> (<span>event</span>) {\n  <span>const</span> cbList = <span>this</span>.<span>events</span>[event]\n  <span>if</span> (!cbList) {\n    <span>console</span>.<span>error</span>(<span>'你注册了事件嘛QAQ'</span>)\n    <span>return</span>\n  }\n  <span>let</span> args = <span>Array</span>.<span>from</span>(<span>arguments</span>).<span>slice</span>(<span>1</span>)\n  cbList.<span>forEach</span>(<span>(<span>cb</span>) =></span> {\n    cb.<span>apply</span>(<span>this</span>, args)\n  })\n}\n\n<span>let</span> foo = <span>new</span> <span>EventEmiter</span>()\n\n<span>/**\n * 或者这样也行\n * function foo(num) {\n  this.events = {}\n  }\n Object.setPrototypeOf(foo, EventEmiter.prototype)\n */</span>\n\nfoo.<span>on</span>(<span>'mEvent'</span>, <span>function</span> (<span>res, a</span>) {\n  <span>console</span>.<span>log</span>(<span>'success'</span>, res, a)\n})\n\n\n<span>setTimeout</span>(<span>() =></span> {\n  foo.<span>emit</span>(<span>'mEvent'</span>, <span>'发射！！！'</span>, <span>'剩余氧气: undefined'</span>)\n}, <span>1000</span>)\n</code></pre>\n<h3 id=\"user-content-总结\"><a href=\"#%E6%80%BB%E7%BB%93\" aria-hidden=\"true\" tabindex=\"-1\"><span></span></a>总结</h3>\n<p>监听器本质是一个个<strong>事件</strong>，是<strong>观察者模式</strong>的实现。OVER！！！</p>\n","title":"js实现自定义监听器","date":"2020-12-23T14:03:56.000Z","description":"在浏览器端与js端分别实现自定义监听器","tag":"JavaScript"}},"__N_SSG":true}