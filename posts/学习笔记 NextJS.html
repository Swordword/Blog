<!DOCTYPE html><html lang="zh-Hans"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><meta name="description" content="Learn how to build a personal website using Next.js"/><meta property="og:image" content="https://og-image.now.sh/Swordword&#x27;s%20blog.png?theme=light&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><meta name="og:title" content="Swordword&#x27;s blog"/><title>学习笔记 Next.JS使用教程</title><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/876d048b5dab7c28.css" as="style"/><link rel="stylesheet" href="/_next/static/css/876d048b5dab7c28.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-a03f34702f60fafc.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-7c48f75ce2db1491.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e272e05dd28ef959.js" defer=""></script><script src="/_next/static/chunks/130-b952c5d507d712ac.js" defer=""></script><script src="/_next/static/chunks/749-555cb8054e68346e.js" defer=""></script><script src="/_next/static/chunks/241-e8e3e8578555aa77.js" defer=""></script><script src="/_next/static/chunks/783-464c81cbfd42177e.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-4108770bd2d21ccc.js" defer=""></script><script src="/_next/static/yk5Zpotj4p9R4XPv5qhw8/_buildManifest.js" defer=""></script><script src="/_next/static/yk5Zpotj4p9R4XPv5qhw8/_ssgManifest.js" defer=""></script></head><body><div id="__next"><style data-emotion="css dbbey5">.css-dbbey5{width:100vw;height:100vh;overflow-y:scroll;background:#eee;color:#3c4858;padding-bottom:50px;}</style><div class="css-dbbey5"><style data-emotion="css gpj3uu">.css-gpj3uu{width:100%;height:50px;color:#fff;background-color:rgba(47,65,84,0.7);box-shadow:0 2px 5px 0 rgb(0 0 0 / 16%),0 2px 10px 0 rgb(0 0 0 / 12%);position:fixed;top:0;left:0;z-index:2;}</style><div class="css-gpj3uu"><style data-emotion="css qjodyr">.css-qjodyr{width:1100px;height:100%;margin:auto;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><div class="css-qjodyr"><a href="/"><style data-emotion="css 19m5m0c">.css-19m5m0c{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:start;-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;}</style><div class="css-19m5m0c"><style data-emotion="css l2tq7e">.css-l2tq7e{width:30px;height:30px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><div class="css-l2tq7e"><style data-emotion="css brme6v">.css-brme6v{width:24px;height:24px;margin-left:6px;}</style><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-sword"></use></svg></div><style data-emotion="css 879ic9">.css-879ic9{margin-left:20px;}</style><div class="css-879ic9">Swordword</div></div></a><style data-emotion="css fhxb3m">.css-fhxb3m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><div class="css-fhxb3m"><a href="/"><style data-emotion="css kfc5ms">.css-kfc5ms{width:100px;height:50px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;}.css-kfc5ms:hover{color:#30A9DE;background-color:rgba(0,0,0,0.1);}</style><div class="css-kfc5ms"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-home"></use></svg></div><style data-emotion="css 1a2afmv">.css-1a2afmv{margin-left:10px;}</style><div class="css-1a2afmv">首页</div></div></a><style data-emotion="css 1lwiia1">.css-1lwiia1{width:100px;height:50px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;position:relative;}.css-1lwiia1:hover .nav-list{display:block;}</style><div class="css-1lwiia1"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-list"></use></svg></div><div class="css-1a2afmv">索引</div><style data-emotion="css su4vv2">.css-su4vv2{-webkit-transition:3s ease-out;transition:3s ease-out;display:none;width:100px;position:absolute;top:50px;left:0;background-color:rgba(47,65,84,0.7);box-shadow:0 2px 5px 0 rgb(0 0 0 / 16%),0 2px 10px 0 rgb(0 0 0 / 12%);}</style><div class="nav-list css-su4vv2"><a href="/archive"><div class="css-kfc5ms"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-guidang"></use></svg></div><div class="css-1a2afmv">归档</div></div></a><a href="/category"><div class="css-kfc5ms"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-leimupinleifenleileibie2"></use></svg></div><div class="css-1a2afmv">分类</div></div></a><a href="/tag"><div class="css-kfc5ms"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-tag1"></use></svg></div><div class="css-1a2afmv">标签</div></div></a></div></div><a href="/about"><div class="css-kfc5ms"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-lianhe4"></use></svg></div><div class="css-1a2afmv">关于</div></div></a><a href="/rss"><div class="css-kfc5ms"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-rss"></use></svg></div><div class="css-1a2afmv">RSS</div></div></a><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-OOjs_UI_icon_search-ltr"></use></svg></div><div class="css-1a2afmv"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-sun"></use></svg></div></div></div></div></div><style data-emotion="css 1739oy8">.css-1739oy8{z-index:1;}</style><div class="css-1739oy8"><style data-emotion="css z6d19t">.css-z6d19t{width:100%;height:350px;position:relative;background:url(/_next/static/media/banner.eb35a883.jpg) center;}</style><div class="css-z6d19t"></div></div><style data-emotion="css 3vwp2t">.css-3vwp2t{position:relative;width:1100px;background:#fff;padding:50px 100px;margin:-150px auto 50px;border-radius:8px;}</style><main class="css-3vwp2t"><article style="color:#3c4858"><style data-emotion="css yrjjfw">.css-yrjjfw{height:70px;margin:0;line-height:70px;text-align:center;font-size:40px;}</style><h1 class="css-yrjjfw">学习笔记 Next.JS使用教程</h1><style data-emotion="css faxeo3">.css-faxeo3{margin-left:250px;}</style><div class="css-faxeo3"><style data-emotion="css hc4w4d">.css-hc4w4d{height:40px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:start;-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><div class="css-hc4w4d"><style data-emotion="css 12qt3ml">.css-12qt3ml{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:start;-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><div class="css-12qt3ml"><style data-emotion="css 2ldgmb">.css-2ldgmb{color:#30a9de;}</style><small class="css-2ldgmb"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-time"></use></svg></div></small><style data-emotion="css qq1p72">.css-qq1p72{margin-left:10px;margin-right:20px;cursor:pointer;}</style><small class="css-qq1p72"><a href="/archive"><span><time dateTime="2021-04-23T13:47:05.000Z">21-04-23</time></span></a></small></div><div class="css-12qt3ml"><small class="css-2ldgmb"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-leimupinleifenleileibie2"></use></svg></div></small><small class="css-qq1p72"><a href="/category/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F"><span>程序人生</span></a></small></div><div class="css-12qt3ml"><small class="css-2ldgmb"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-tag1"></use></svg></div></small><small class="css-qq1p72"><a href="/tag/react"><span>React<!-- --> </span></a><a href="/tag/%20next.js"><span> Next.js<!-- --> </span></a></small></div></div></div><style data-emotion="css h25mx1">.css-h25mx1{border-bottom:1px solid #30a9de;margin-top:20px;margin-bottom:20px;}</style><div class="css-h25mx1"></div><div><p>Next.js 是一个基于 React 的服务端渲染框架，但是它能做的显然不止于此</p>
<h3 id="user-content-项目初始化"><a href="#%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96" aria-hidden="true" tabindex="-1"><span></span></a>项目初始化</h3>
<h4 id="user-content-"></h4>
<h3 id="user-content-页面展示"><a href="#%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA" aria-hidden="true" tabindex="-1"><span></span></a>页面展示</h3>
<p>pages 文件夹下面的每个命名组件都作为软件的一个页面存在，</p>
<h4 id="user-content-预渲染"><a href="#%E9%A2%84%E6%B8%B2%E6%9F%93" aria-hidden="true" tabindex="-1"><span></span></a>预渲染</h4>
<h5 id="user-content-静态生成-static-generation"><a href="#%E9%9D%99%E6%80%81%E7%94%9F%E6%88%90-static-generation" aria-hidden="true" tabindex="-1"><span></span></a>静态生成 Static Generation</h5>
<p><strong>静态生成</strong>是在项目打包部署时生成的页面，即打包完成后，页面内容是保持不变的。可以通过CDN进行缓存</p>
<p>Next.js 默认情况下，页面都是静态生成的，若只是一个单纯的不需要额外数据的页面。写法与React组件基本相同</p>
<p><strong>带有数据的静态渲染</strong></p>
<p><strong>页面内容由额外数据决定</strong></p>
<p>为了在打包时获取到额外数据，可以 导出一个异步函数<code>getStaticProps</code>,导出一个props对象供 React 组件使用</p>
<pre><code><span>const</span> <span>Index</span> = (<span>data</span>) => {
  <span>// {data.name}</span>
}
<span>export</span> <span>async</span> <span>function</span> <span>getStaticProps</span>(<span></span>) {
  <span>let</span> data = {
    <span>name</span>: <span>'John'</span>,
  }
  <span>return</span> {
    <span>props</span>: data,
  }
}
<span>export</span> <span>default</span> <span>Index</span></code></pre>
<p><code>getStaticProps(context): ReturnObject</code> 打包时决定 React 可以使用的 <code>props</code>,不会在浏览器端代码出现（666）,并且只能在页面组件中使用这个函数，</p>
<p>参数<code>context</code>由以下属性组成</p>
<ul>
<li><code>params</code>：动态路由情况下每个页面的<code>id</code>值在此生成</li>
<li><code>preview</code>：判断页面是否处于预览模式。在部署之前跳过部署提前预览页面</li>
<li><code>previewData</code>：通过<code>setPreviewData</code>返回的预览数据</li>
<li><code>locale</code>：当前活动地区？</li>
<li><code>locales</code>：所有支持的地区</li>
<li><code>defaultLocale</code>：默认活动区域</li>
</ul>
<p>返回的<code>ReturnObject</code>应该包含以下元素</p>
<ul>
<li>
<p><code>props</code>：必填项，React 组件接受的props对象。</p>
</li>
<li>
<p><code>revalidate</code>：可选项，多少秒这个页面重新生成?</p>
</li>
<li>
<p><code>notFound</code>：可选bool值，使页面返回 404 状态</p>
</li>
<li>
<p><code>redirect</code>：可选项，用于跳转至另一个页面。格式如<code>{ destination: string, permanent: boolean}</code>，<code>destination</code>代表跳转的路径，<code>permanent</code>表明是否永久跳转？</p>
<p>一个使用<code>notFound</code>和<code>redirect</code>的示例</p>
<pre><code><span>export</span> <span>async</span> <span>function</span> <span>getStaticProps</span>(<span>context</span>) {
  <span>const</span> res = <span>await</span> <span>fetch</span>(<span>`https://.../data`</span>)
  <span>const</span> data = <span>await</span> res.<span>json</span>()
  <span>if</span> (!data) {
    <span>// </span>
    <span>return</span> {
      <span>notFound</span>: <span>true</span>,
    }
    <span>//</span>
    <span>return</span> {
      <span>redirect</span>:{
        <span>destination</span>: <span>'/'</span>,
        <span>permanent</span>: <span>false</span>,
      }
    }
  }
  <span>return</span> {
    <span>props</span>: { data }
  }
}</code></pre>
</li>
</ul>
<p><strong>页面路径由额外数据决定</strong></p>
<p>Next.js提供了之前 Gatsby 才有的动态路由，这也是我放弃 Gatsby 的原因( GraphQL 搞不懂是另一个)。</p>
<p>可以创建一个文件<code>pages/posts/[id].js</code>，根据传入的<code>id</code>决定展示哪个页面, 可以在<code>[id].js</code>导出一个异步方法<code>getStaticPaths</code>返回一个路径集合数组,类似<code>[{params:{id:1}},{params:{id:1}]</code>。再使用<code>getStaticProps(context)</code>中的<code>context.params.id</code>获取<code>id</code>动态生成内容</p>
<pre><code><span>// [id].js</span>
<span>const</span> <span>Post</span> = (<span>data</span>) => {
  <span>// {data.contentHtml}</span>
}

<span>export</span> <span>async</span> <span>function</span> <span>getStaticPaths</span>(<span></span>){
  <span>return</span> [
    {<span>params</span>:{<span>id</span>:<span>1</span>}},
    {<span>params</span>:{<span>id</span>:<span>1</span>}
  ]
}

<span>export</span> <span>async</span> <span>function</span> <span>getStaticProps</span>(<span>context</span>){
  <span>const</span> id = context?.<span>params</span>?.<span>id</span>
  <span>const</span> data = <span>loadData</span>(id)
  <span>return</span> {<span>props</span>: data}
}

<span>export</span> <span>default</span> <span>Post</span>;</code></pre>
<p><code>getStaticPaths: ReturnObject</code>：打包前获取所有的动态路径</p>
<p><code>ReturnObject</code> 包含属性</p>
<ul>
<li>
<p><code>paths</code>：必填项，路径数组 <code>[{params:{id:'1'}},{params:{id:"2"}}]</code></p>
<p><code>params</code>必须与 pages 文件夹 中的文件名称对应</p>
<ul>
<li>如果 page 文件名称是<code>pages/posts/[postId]/[commentId]</code>，<code>params</code>必须含有<code>postId</code>与<code>commentId</code></li>
<li>如果使用类数组路由, page 文件名称是<code>pages/posts/[...slug]</code>，<code>params</code>必须包含一个<code>slug</code>的数组</li>
<li>如果使用可选类数组路由，可以使用 <code>null</code>, <code>[]</code>, <code>undefined</code> 或 <code>false</code> 渲染根路由。例如，对于<code>pages/[[...slug]]</code>,如果<code>slug: false</code>,会渲染/页面</li>
</ul>
</li>
<li>
<p><code>fallback</code>必填项，访问路径不存在时的处理情况</p>
<ul>
<li><code>fallback: false</code>：如果当前访问路径不在<code>paths</code>对象中,访问404页面。每次添加新页面时，都需要重新打包</li>
<li><code>fallback: true</code>：访问路径不在<code>paths</code>中不会导致404，Next.js 前端会创建一个<code>fallback</code>版本以供使用，在后端重新走一遍<code>getStaticPaths</code>，重新创建一个对应访问路径页面，并放到预渲染<code>paths</code>对象中以供以后使用</li>
<li><code>fallback:blocking</code>：访问路径不在<code>paths</code>中不会导致404，Next.js 会通过服务端渲染</li>
</ul>
</li>
<li>
<p>Fallback pages</p>
<p>在<code>fallback</code>版本时，<code>page</code>的<code>props</code>为空,如果使用<code>next/router</code>,<code>router.isFallback</code>是<code>true</code></p>
<pre><code><span>const</span> <span>Post</span> = (<span>{ data }</span>) => {
  <span>const</span> router = <span>useRouter</span>()
  <span>if</span> (router.<span>isFallback</span>) {
    <span>return</span> <span><span>&#x3C;<span>div</span>></span>Loading...<span>&#x3C;/<span>div</span>></span></span>
  }
  <span>return</span> <span><span>&#x3C;<span>div</span>></span>{data}page<span>&#x3C;/<span>div</span>></span></span>
}
<span>export</span> <span>async</span> <span>function</span> <span>getStaticPaths</span>(<span></span>) {
  <span>return</span> {
    <span>paths</span>: [
      {
        <span>params</span>: {
          <span>id</span>: <span>'1'</span>,
        },
      },
    ],
    <span>fallback</span>: <span>true</span>,
  }
}
<span>export</span> <span>async</span> <span>function</span> <span>getStaticProps</span>(<span>context</span>) {
  <span>const</span> id = context.<span>params</span>.<span>id</span>
  <span>return</span> {
    <span>props</span>: {
      <span>data</span>: id,
    },
    <span>revalidate</span>: <span>true</span>,
  }
}
<span>export</span> <span>default</span> <span>Post</span></code></pre>
</li>
</ul>
<h5 id="user-content-服务端渲染-server-side-rendering"><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93-server-side-rendering" aria-hidden="true" tabindex="-1"><span></span></a>服务端渲染 Server-side Rendering</h5>
<p><strong>服务端渲染</strong>在每个请求都会根据内容重新生成页面</p>
<p>类似<code>getStaticProps</code>,可以使用<code>getServerSideProps</code>返回一个props对象,在每次请求时都会走一遍这个函数并重新生成页面</p>
<pre><code><span>const</span> <span>Index</span> = (<span>data</span>) => {
  <span>// {data.name}</span>
}
<span>export</span> <span>async</span> <span>function</span> <span>getServerSideProps</span>(<span></span>) {
  <span>let</span> data = {
    <span>name</span>: <span>'John'</span>,
  }
  <span>return</span> {
    <span>props</span>: data,
  }
}
<span>export</span> <span>default</span> <span>Index</span></code></pre>
<p><code>getServerSideProps(context):ReturnObject</code>：用于服务端渲染的异步函数，返回一个props对象供 React 组件使用。同样的，不会在浏览器端代码出现该函数,并且只能在页面组件中使用这个函数，</p>
<pre><code><span>export</span> <span>async</span> <span>function</span> <span>getServerSideProps</span>(<span>context</span>) {
  <span>return</span> {
    <span>props</span>: {},
  }
}</code></pre>
<p><code>context</code>：包含以下属性</p>
<ul>
<li><code>params</code>：同<code>getStaticProps</code></li>
<li><code>req</code>：请求对象</li>
<li><code>res</code>：响应对象</li>
<li><code>query</code>：query string 的对象</li>
<li><code>preview</code>：同<code>getStaticProps</code></li>
<li><code>previewData</code>：同<code>getStaticProps</code></li>
<li><code>resolvedUrl</code>：请求URL的规范化版本</li>
<li><code>locale</code>：同<code>getStaticProps</code></li>
<li><code>locales</code>：同<code>getStaticProps</code></li>
<li><code>defaultLocale</code>：同<code>getStaticProps</code></li>
</ul>
<p>ReturnObject包含以下属性：</p>
<ul>
<li><code>props</code>：同<code>getStaticProps</code></li>
<li><code>notFound</code>：同<code>getStaticProps</code></li>
<li><code>redirect</code>：同<code>getStaticProps</code></li>
</ul>
<h5 id="user-content-增量静态生成-incremental-static-regeneration-"><a href="#%E5%A2%9E%E9%87%8F%E9%9D%99%E6%80%81%E7%94%9F%E6%88%90-incremental-static-regeneration-" aria-hidden="true" tabindex="-1"><span></span></a>增量静态生成 Incremental Static Regeneration ?</h5>
<p>感觉像动态部署，部署时不会导致服务切断。返回时添加一个<code>revalidate: second</code>表明在几秒之后重新部署</p>
<h3 id="user-content-样式集成"><a href="#%E6%A0%B7%E5%BC%8F%E9%9B%86%E6%88%90" aria-hidden="true" tabindex="-1"><span></span></a>样式集成</h3>
<h4 id="user-content-全局样式"><a href="#%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F" aria-hidden="true" tabindex="-1"><span></span></a>全局样式</h4>
<p>创建文件<code>pages/_app.js</code>，在该文件中的样式会在所有页面和组件中生效</p>
<pre><code><span>// _app.js</span>
<span>import</span> <span>'../styles.css'</span>

<span>// This default export is required in a new `pages/_app.js` file.</span>
<span>export</span> <span>default</span> <span>function</span> <span>MyApp</span>(<span>{ Component, pageProps }</span>) {
  <span>return</span> <span><span>&#x3C;<span>Component</span> {<span>...pageProps</span>} /></span></span>
}</code></pre>
<h4 id="user-content-范围样式"><a href="#%E8%8C%83%E5%9B%B4%E6%A0%B7%E5%BC%8F" aria-hidden="true" tabindex="-1"><span></span></a>范围样式</h4>
<p>Next.js 支持<a href="https://github.com/css-modules/css-modules">CSS Modules</a> 为每个组件赋予独立的样式。命名为<code>[name].module.css</code>。会在每个<code>class</code>后添加一个 Hash 值</p>
<h4 id="user-content-sass-支持"><a href="#sass-%E6%94%AF%E6%8C%81" aria-hidden="true" tabindex="-1"><span></span></a>Sass 支持</h4>
<p><code>npm install sass</code>即可在项目中使用 sass 或 scss</p>
<p><strong>自定义 Sass 配置</strong></p>
<p>可以通过在<code>next.config.js</code>中的<code>sassOptions</code>对 sass 进行配置</p>
<pre><code><span>const</span> path = <span>require</span>(<span>'path'</span>)

<span>module</span>.<span>exports</span> = {
  <span>sassOptions</span>: {
    <span>includePaths</span>: [path.<span>join</span>(__dirname, <span>'styles'</span>)],
  },
}</code></pre>
<h4 id="user-content-css-in-js"><a href="#css-in-js" aria-hidden="true" tabindex="-1"><span></span></a>CSS-in-JS</h4>
<p>基本上和create-react-app一样，Next.js 内置了<a href="https://github.com/vercel/styled-jsx">styled-jsx</a>。实现<a>styled-component</a>和<a href="https://emotion.sh/docs/introduction">emotion</a>的效果</p>
<h3 id="user-content-图形组件与优化"><a href="#%E5%9B%BE%E5%BD%A2%E7%BB%84%E4%BB%B6%E4%B8%8E%E4%BC%98%E5%8C%96" aria-hidden="true" tabindex="-1"><span></span></a>图形组件与优化</h3>
<p>Next.js 提供了与Gatsby一样优化很棒的图像组件<code>next/image</code>，<code>Image</code>支持常见的懒加载，resize，以现代格式显示图片等功能。</p>
<h4 id="user-content-配置"><a href="#%E9%85%8D%E7%BD%AE" aria-hidden="true" tabindex="-1"><span></span></a>配置</h4>
<p>可以在<code>next.config.js</code>配置images获得最优化的效果</p>
<p><strong>支持外部网站</strong></p>
<p>加载一个外部网站托管的图片，在<code>next.config.js</code>中配置<code>images</code>的<code>domains</code>字段</p>
<p><strong>自定义加载器</strong></p>
<p>Next.js  可以自定义自己的图形加载器，通过配置<code>images</code>的<code>loader</code>字段</p>
<p><strong>缓存</strong></p>
<p>Next.js 默认会将访问过的图片缓存至<code>&#x3C;distDir>/cache/images</code>文件夹。缓存时间有服务端的<code>Cache-Control</code>字段控制：<code>s-maxage||max-age||60s</code></p>
<pre><code><span>module</span>.<span>exports</span> = {
  <span>images</span>: {
    <span>// 外部域名</span>
    <span>domains</span>: [<span>'example.com'</span>],
    <span>// 自定义加载器</span>
   	<span>loader</span>: <span>'imgix'</span>,
    <span>path</span>: <span>'https://example.com/myaccount/'</span>,
  },
}</code></pre>
<h3 id="user-content-静态文件托管"><a href="#%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E6%89%98%E7%AE%A1" aria-hidden="true" tabindex="-1"><span></span></a>静态文件托管</h3>
<p><code>public</code>文件夹下的文件会作为 Next.js 的静态文件夹。可以通过URL<code>/</code>进行访问</p>
<h2 id="user-content-路由"><a href="#%E8%B7%AF%E7%94%B1" aria-hidden="true" tabindex="-1"><span></span></a>路由</h2>
<p>正如上文所说，Next.js 在<code>pages</code>文件夹下的每个文件都是一个路由，路由名称与文件目录相同</p>
<h4 id="user-content-路由规则"><a href="#%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99" aria-hidden="true" tabindex="-1"><span></span></a>路由规则</h4>
<ul>
<li><code>pages/index.js</code> → <code>/</code></li>
<li><code>pages/blog/index.js</code> → <code>/blog</code></li>
<li><code>pages/blog/first-post.js</code> → <code>/blog/first-post</code></li>
<li><code>pages/dashboard/settings/username.js</code> → <code>/dashboard/settings/username</code></li>
</ul>
<p><strong>路由动态切片</strong></p>
<p>可以使用大括号语法定义一个切片路由</p>
<ul>
<li><code>pages/blog/[slug].js</code> → <code>/blog/:slug</code> (<code>/blog/hello-world</code>)</li>
<li><code>pages/[username]/settings.js</code> → <code>/:username/settings</code> (<code>/foo/settings</code>)</li>
<li><code>pages/post/[...all].js</code> → <code>/post/*</code> (<code>/post/2020/id/title</code>)</li>
</ul>
<h3 id="user-content-动态路由"><a href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1" aria-hidden="true" tabindex="-1"><span></span></a>动态路由</h3>
<p>在一些app中，比如博客系统，路由的路径很难预先定义，可以在pages文件夹下设置方括号定义动态路由，例如<code>pages/post/[id].js</code>, 会匹配任何类似<code>/post/1</code>,<code>/post/a</code>的路由</p>
<pre><code><span>import</span> { useRouter } <span>from</span> <span>'next/router'</span>

<span>const</span> <span>Post</span> = (<span></span>) => {
  <span>const</span> router = <span>useRouter</span>()
  <span>const</span> { pid } = router.<span>query</span>

  <span>return</span> <span><span>&#x3C;<span>p</span>></span>Post: {pid}<span>&#x3C;/<span>p</span>></span></span>
}

<span>export</span> <span>default</span> <span>Post</span></code></pre>
<h4 id="user-content-路由跳转"><a href="#%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC" aria-hidden="true" tabindex="-1"><span></span></a>路由跳转</h4>
<p>通过<code>next/link</code>的<code>Link</code>组件,允许浏览器端跳转页面</p>
<pre><code><span>import</span> <span>Link</span> <span>from</span> <span>'next/link'</span>
<span>function</span> <span>Home</span>(<span></span>) {
  <span>return</span> (
    <span><span>&#x3C;></span>
      <span>&#x3C;<span>Link</span> <span>href</span>=<span>"/home"</span>></span>
        <span>&#x3C;<span>a</span>></span>Home<span>&#x3C;/<span>a</span>></span>
      <span>&#x3C;/<span>Link</span>></span>
    	<span>&#x3C;<span>Link</span> <span>href</span>=<span>{</span>`/<span>blog</span>/${<span>encodeURIComponent</span>(<span>post.slug</span>)}`}></span>
        <span>&#x3C;<span>a</span>></span>{post.title}<span>&#x3C;/<span>a</span>></span>
			<span>&#x3C;/<span>Link</span>></span>
    // href 对象,pathname表明文件所在路径 
      <span>&#x3C;<span>Link</span>
        <span>href</span>=<span>{{</span>
          <span>pathname:</span> '/<span>blog</span>/[<span>slug</span>]',
          <span>query:</span> { <span>slug:</span> <span>post.slug</span> },
        }}
      ></span>
        <span>&#x3C;<span>a</span>></span>{post.title}<span>&#x3C;/<span>a</span>></span>
      <span>&#x3C;/<span>Link</span>></span>
    <span>&#x3C;/></span></span>
  )
}</code></pre>
<h4 id="user-content-捕获所有路由"><a href="#%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E8%B7%AF%E7%94%B1" aria-hidden="true" tabindex="-1"><span></span></a>捕获所有路由</h4>
<p>可以在方括号中添加拓展运算符<code>...</code>捕获所有路由</p>
<p><code>pages/post/[...slug].js</code>匹配<code>/post/a</code>,<code>/post/a/b</code>。这种情况下, <code>router.query</code>的<code>slug</code>会是一个数组<code>['a','b']</code></p>
<p><strong>Optional 捕获所有路由</strong></p>
<p><code>pages</code>文件夹名称是双括号包裹的话，可以匹配根路由。<code>pages/post/[[...slug]].js</code>可以匹配<code>/post</code>,<code>/post/a</code>,<code>/post/a/b</code></p>
<h4 id="user-content-路由注入"><a href="#%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%85%A5" aria-hidden="true" tabindex="-1"><span></span></a>路由注入</h4>
<p>使用<code>useRouter</code> hook进行路由注入,命令式的跳转路由</p>
<pre><code><span>// post/aa&#x26;name=bb</span>
<span>import</span> { useRouter } <span>from</span> <span>'next/router'</span>
<span>const</span> router = <span>useRouter</span>()
<span>const</span> { pid } = router.<span>query</span>	<span>// {pid:'aa', name:'bb'}</span>
&#x3C;span onClick={<span>() =></span> router.<span>push</span>(<span>'/about'</span>)}><span>Click</span> here to read more&#x3C;/span></code></pre>
<h4 id="user-content-浅层路由"><a href="#%E6%B5%85%E5%B1%82%E8%B7%AF%E7%94%B1" aria-hidden="true" tabindex="-1"><span></span></a>浅层路由</h4>
<p>浅层路由允许你在不加载具体页面内容的前提下，修改路由。不知道有啥用</p>
<pre><code><span>import</span> { useEffect } <span>from</span> <span>'react'</span>
<span>import</span> { useRouter } <span>from</span> <span>'next/router'</span>
<span>const</span> router = <span>useRouter</span>()
<span>useEffect</span>(<span>() =></span> {
   router.<span>push</span>(<span>'/?counter=10'</span>, <span>undefined</span>, { <span>shallow</span>: <span>true</span> })
}, [])</code></pre>
<h3 id="user-content-打包部署"><a href="#%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2" aria-hidden="true" tabindex="-1"><span></span></a>打包部署</h3>
<h3 id="user-content-typescript集成"><a href="#typescript%E9%9B%86%E6%88%90" aria-hidden="true" tabindex="-1"><span></span></a>TypeScript集成</h3>
<p>创建<code>tsconfig.json</code>，<code>yarn add --dev typescript @types/react @types/node</code>即可在 Next.js 中使用 typescript</p>
<h4 id="user-content-常见的渲染方法"><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B8%B2%E6%9F%93%E6%96%B9%E6%B3%95" aria-hidden="true" tabindex="-1"><span></span></a>常见的渲染方法</h4>
<pre><code><span>import</span> { <span>GetStaticProps</span>, <span>GetStaticPaths</span>, <span>GetServerSideProps</span> } <span>from</span> <span>'next'</span>

<span>export</span> <span>const</span> <span>getStaticProps</span>: <span>GetStaticProps</span> = <span>async</span> (context) => {
  <span>// ...</span>
}

<span>export</span> <span>const</span> <span>getStaticPaths</span>: <span>GetStaticPaths</span> = <span>async</span> () => {
  <span>// ...</span>
}

<span>export</span> <span>const</span> <span>getServerSideProps</span>: <span>GetServerSideProps</span> = <span>async</span> (context) => {
  <span>// ...</span>
}</code></pre>
<p>如果想要在 React 组件中的 props引用类型，可以使用<code>InferGetStaticPropsType&#x3C;typeof getStaticProps></code></p>
<pre><code><span>import</span> { <span>InferGetStaticPropsType</span> } <span>from</span> <span>'next'</span>

<span>type</span> <span>Post</span> = {
  <span>author</span>: <span>string</span>
  <span>content</span>: <span>string</span>
}

<span>// 这种情况就不需要使用 GetStaticProps，InferGetStaticPropsType 会自动生成 props 类型</span>
<span>export</span> <span>const</span> <span>getStaticProps</span> = <span>async</span> (<span></span>) => {
  <span>const</span> res = <span>await</span> <span>fetch</span>(<span>'https://.../posts'</span>)
  <span>const</span> <span>posts</span>: <span>Post</span>[] = <span>await</span> res.<span>json</span>()

  <span>return</span> {
    <span>props</span>: {
      posts,
    },
  }
}

<span>function</span> <span>Blog</span>(<span>{ posts }: InferGetStaticPropsType&#x3C;<span>typeof</span> getStaticProps></span>) {
  <span>// will resolve posts to type Post[]</span>
}

<span>export</span> <span>default</span> <span>Blog</span></code></pre>
<h4 id="user-content-api-路由"><a href="#api-%E8%B7%AF%E7%94%B1" aria-hidden="true" tabindex="-1"><span></span></a>API 路由</h4>
<p>在<code>pages/api</code>中可以自定义一些接口</p>
<pre><code><span>import</span> <span>type</span> { <span>NextApiRequest</span>, <span>NextApiResponse</span> } <span>from</span> <span>'next'</span>

<span>type</span> <span>Data</span> = {
  <span>name</span>: <span>string</span>
}

<span>export</span> <span>default</span> (<span>req</span>: <span>NextApiRequest</span>, <span>res</span>: <span>NextApiResponse</span>&#x3C;<span>Data</span>>) => {
  res.<span>status</span>(<span>200</span>).<span>json</span>({ <span>name</span>: <span>'John Doe'</span> })
}</code></pre>
<h4 id="user-content-custom-app"><a href="#custom-app" aria-hidden="true" tabindex="-1"><span></span></a>Custom <code>App</code></h4>
<p>比如在<code>_app.tsx</code>中自定义 App 组件</p>
<pre><code><span>// import App from "next/app";</span>
<span>import</span> <span>type</span> { <span>AppProps</span> <span>/*, AppContext */</span> } <span>from</span> <span>'next/app'</span>

<span>function</span> <span>MyApp</span>(<span>{ Component, pageProps }: AppProps</span>) {
  <span>return</span> <span><span>&#x3C;<span>Component</span> {<span>...pageProps</span>} /></span></span>
}

<span>// Only uncomment this method if you have blocking data requirements for</span>
<span>// every single page in your application. This disables the ability to</span>
<span>// perform automatic static optimization, causing every page in your app to</span>
<span>// be server-side rendered.</span>
<span>//</span>
<span>// MyApp.getInitialProps = async (appContext: AppContext) => {</span>
<span>//   // calls page's `getInitialProps` and fills `appProps.pageProps`</span>
<span>//   const appProps = await App.getInitialProps(appContext);</span>

<span>//   return { ...appProps }</span>
<span>// }</span>

<span>export</span> <span>default</span> <span>MyApp</span></code></pre>
<h3 id="user-content-环境变量"><a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" aria-hidden="true" tabindex="-1"><span></span></a>环境变量</h3>
<p>可以在项目根目录添加<code>.env/*</code>配置环境变量,其中<code>.env</code>和<code>.env.local</code>会作为默认配置，<code>.env.development</code>会作为开发环境的变量, <code>.env.production</code>会作为生产环境的变量设置</p>
<p>环境变量中的变量可以通过<code>$</code>访问之前的变量</p>
<p>环境变量只能被<code>node</code>环境使用,如果想在浏览器端使用环境变量，需要在变量名前添加<code>NEXT_PUBLIC_</code>前缀</p>
<pre><code><span># .env</span>
HOSTNAME=localhost
PORT=8080
HOST=http://<span>$HOSTNAME</span>:<span>$PORT</span>
NEXT_PUBLIC_ANALYTICS_ID=abcdefghijk</code></pre>
<h3 id="user-content-api-路由-1"><a href="#api-%E8%B7%AF%E7%94%B1-1" aria-hidden="true" tabindex="-1"><span></span></a>API 路由</h3>
<p><code>pages/api/*</code>中的文件会作为 api 接口而不是作为页面使用</p>
<pre><code><span>// pages/api/hello</span>
<span>export</span> <span>default</span> <span>function</span> <span>handler</span>(<span>req, res</span>) {
  res.<span>status</span>(<span>200</span>).<span>json</span>({ <span>name</span>: <span>'John Doe'</span> })
}</code></pre>
<p>访问<code>/api/hello</code>会返回一个 json 字符串</p>
<p>API 路由也支持像 <code>pages</code>那样的动态路由</p>
<h4 id="user-content-api-中间件"><a href="#api-%E4%B8%AD%E9%97%B4%E4%BB%B6" aria-hidden="true" tabindex="-1"><span></span></a>API 中间件</h4>
<p>目前没有在 Next 中使用过</p>
<h3 id="user-content-高级特性"><a href="#%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7" aria-hidden="true" tabindex="-1"><span></span></a>高级特性</h3>
<h3 id="user-content-注意事项"><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" aria-hidden="true" tabindex="-1"><span></span></a>注意事项</h3>
<h4 id="user-content-读取文件使用processcwd"><a href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8processcwd" aria-hidden="true" tabindex="-1"><span></span></a>读取文件使用<code>process.cwd()</code></h4>
<p>Next.js编译代码是在一个独立的文件夹，所以不能使用<code>__dirname</code>获取文件夹目录,<code>process.cwd()</code>返回 Next.js 执行的目录</p>
<h4 id="user-content-getstaticpaths-和-getserversideprops不能同时使用"><a href="#getstaticpaths-%E5%92%8C-getserversideprops%E4%B8%8D%E8%83%BD%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8" aria-hidden="true" tabindex="-1"><span></span></a><code>getStaticPaths</code> 和 <code>getServerSideProps</code>不能同时使用</h4>
</div></article></main></div><style data-emotion="css 1st94pw">.css-1st94pw{text-align:center;height:30px;line-height:30px;color:#333;}</style><div class="css-1st94pw"><a href="https://beian.miit.gov.cn/" target="_blank" rel="noreferrer">京ICP备19054504号-2</a></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"学习笔记 NextJS","contentHtml":"\u003cp\u003eNext.js 是一个基于 React 的服务端渲染框架，但是它能做的显然不止于此\u003c/p\u003e\n\u003ch3 id=\"user-content-项目初始化\"\u003e\u003ca href=\"#%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e项目初始化\u003c/h3\u003e\n\u003ch4 id=\"user-content-\"\u003e\u003c/h4\u003e\n\u003ch3 id=\"user-content-页面展示\"\u003e\u003ca href=\"#%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e页面展示\u003c/h3\u003e\n\u003cp\u003epages 文件夹下面的每个命名组件都作为软件的一个页面存在，\u003c/p\u003e\n\u003ch4 id=\"user-content-预渲染\"\u003e\u003ca href=\"#%E9%A2%84%E6%B8%B2%E6%9F%93\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e预渲染\u003c/h4\u003e\n\u003ch5 id=\"user-content-静态生成-static-generation\"\u003e\u003ca href=\"#%E9%9D%99%E6%80%81%E7%94%9F%E6%88%90-static-generation\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e静态生成 Static Generation\u003c/h5\u003e\n\u003cp\u003e\u003cstrong\u003e静态生成\u003c/strong\u003e是在项目打包部署时生成的页面，即打包完成后，页面内容是保持不变的。可以通过CDN进行缓存\u003c/p\u003e\n\u003cp\u003eNext.js 默认情况下，页面都是静态生成的，若只是一个单纯的不需要额外数据的页面。写法与React组件基本相同\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e带有数据的静态渲染\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e页面内容由额外数据决定\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e为了在打包时获取到额外数据，可以 导出一个异步函数\u003ccode\u003egetStaticProps\u003c/code\u003e,导出一个props对象供 React 组件使用\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eIndex\u003c/span\u003e = (\u003cspan\u003edata\u003c/span\u003e) =\u003e {\n  \u003cspan\u003e// {data.name}\u003c/span\u003e\n}\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003easync\u003c/span\u003e \u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003egetStaticProps\u003c/span\u003e(\u003cspan\u003e\u003c/span\u003e) {\n  \u003cspan\u003elet\u003c/span\u003e data = {\n    \u003cspan\u003ename\u003c/span\u003e: \u003cspan\u003e'John'\u003c/span\u003e,\n  }\n  \u003cspan\u003ereturn\u003c/span\u003e {\n    \u003cspan\u003eprops\u003c/span\u003e: data,\n  }\n}\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003edefault\u003c/span\u003e \u003cspan\u003eIndex\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003egetStaticProps(context): ReturnObject\u003c/code\u003e 打包时决定 React 可以使用的 \u003ccode\u003eprops\u003c/code\u003e,不会在浏览器端代码出现（666）,并且只能在页面组件中使用这个函数，\u003c/p\u003e\n\u003cp\u003e参数\u003ccode\u003econtext\u003c/code\u003e由以下属性组成\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eparams\u003c/code\u003e：动态路由情况下每个页面的\u003ccode\u003eid\u003c/code\u003e值在此生成\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epreview\u003c/code\u003e：判断页面是否处于预览模式。在部署之前跳过部署提前预览页面\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epreviewData\u003c/code\u003e：通过\u003ccode\u003esetPreviewData\u003c/code\u003e返回的预览数据\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elocale\u003c/code\u003e：当前活动地区？\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elocales\u003c/code\u003e：所有支持的地区\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edefaultLocale\u003c/code\u003e：默认活动区域\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e返回的\u003ccode\u003eReturnObject\u003c/code\u003e应该包含以下元素\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eprops\u003c/code\u003e：必填项，React 组件接受的props对象。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003erevalidate\u003c/code\u003e：可选项，多少秒这个页面重新生成?\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003enotFound\u003c/code\u003e：可选bool值，使页面返回 404 状态\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eredirect\u003c/code\u003e：可选项，用于跳转至另一个页面。格式如\u003ccode\u003e{ destination: string, permanent: boolean}\u003c/code\u003e，\u003ccode\u003edestination\u003c/code\u003e代表跳转的路径，\u003ccode\u003epermanent\u003c/code\u003e表明是否永久跳转？\u003c/p\u003e\n\u003cp\u003e一个使用\u003ccode\u003enotFound\u003c/code\u003e和\u003ccode\u003eredirect\u003c/code\u003e的示例\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003easync\u003c/span\u003e \u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003egetStaticProps\u003c/span\u003e(\u003cspan\u003econtext\u003c/span\u003e) {\n  \u003cspan\u003econst\u003c/span\u003e res = \u003cspan\u003eawait\u003c/span\u003e \u003cspan\u003efetch\u003c/span\u003e(\u003cspan\u003e`https://.../data`\u003c/span\u003e)\n  \u003cspan\u003econst\u003c/span\u003e data = \u003cspan\u003eawait\u003c/span\u003e res.\u003cspan\u003ejson\u003c/span\u003e()\n  \u003cspan\u003eif\u003c/span\u003e (!data) {\n    \u003cspan\u003e// \u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e {\n      \u003cspan\u003enotFound\u003c/span\u003e: \u003cspan\u003etrue\u003c/span\u003e,\n    }\n    \u003cspan\u003e//\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e {\n      \u003cspan\u003eredirect\u003c/span\u003e:{\n        \u003cspan\u003edestination\u003c/span\u003e: \u003cspan\u003e'/'\u003c/span\u003e,\n        \u003cspan\u003epermanent\u003c/span\u003e: \u003cspan\u003efalse\u003c/span\u003e,\n      }\n    }\n  }\n  \u003cspan\u003ereturn\u003c/span\u003e {\n    \u003cspan\u003eprops\u003c/span\u003e: { data }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e页面路径由额外数据决定\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eNext.js提供了之前 Gatsby 才有的动态路由，这也是我放弃 Gatsby 的原因( GraphQL 搞不懂是另一个)。\u003c/p\u003e\n\u003cp\u003e可以创建一个文件\u003ccode\u003epages/posts/[id].js\u003c/code\u003e，根据传入的\u003ccode\u003eid\u003c/code\u003e决定展示哪个页面, 可以在\u003ccode\u003e[id].js\u003c/code\u003e导出一个异步方法\u003ccode\u003egetStaticPaths\u003c/code\u003e返回一个路径集合数组,类似\u003ccode\u003e[{params:{id:1}},{params:{id:1}]\u003c/code\u003e。再使用\u003ccode\u003egetStaticProps(context)\u003c/code\u003e中的\u003ccode\u003econtext.params.id\u003c/code\u003e获取\u003ccode\u003eid\u003c/code\u003e动态生成内容\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// [id].js\u003c/span\u003e\n\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003ePost\u003c/span\u003e = (\u003cspan\u003edata\u003c/span\u003e) =\u003e {\n  \u003cspan\u003e// {data.contentHtml}\u003c/span\u003e\n}\n\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003easync\u003c/span\u003e \u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003egetStaticPaths\u003c/span\u003e(\u003cspan\u003e\u003c/span\u003e){\n  \u003cspan\u003ereturn\u003c/span\u003e [\n    {\u003cspan\u003eparams\u003c/span\u003e:{\u003cspan\u003eid\u003c/span\u003e:\u003cspan\u003e1\u003c/span\u003e}},\n    {\u003cspan\u003eparams\u003c/span\u003e:{\u003cspan\u003eid\u003c/span\u003e:\u003cspan\u003e1\u003c/span\u003e}\n  ]\n}\n\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003easync\u003c/span\u003e \u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003egetStaticProps\u003c/span\u003e(\u003cspan\u003econtext\u003c/span\u003e){\n  \u003cspan\u003econst\u003c/span\u003e id = context?.\u003cspan\u003eparams\u003c/span\u003e?.\u003cspan\u003eid\u003c/span\u003e\n  \u003cspan\u003econst\u003c/span\u003e data = \u003cspan\u003eloadData\u003c/span\u003e(id)\n  \u003cspan\u003ereturn\u003c/span\u003e {\u003cspan\u003eprops\u003c/span\u003e: data}\n}\n\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003edefault\u003c/span\u003e \u003cspan\u003ePost\u003c/span\u003e;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003egetStaticPaths: ReturnObject\u003c/code\u003e：打包前获取所有的动态路径\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eReturnObject\u003c/code\u003e 包含属性\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003epaths\u003c/code\u003e：必填项，路径数组 \u003ccode\u003e[{params:{id:'1'}},{params:{id:\"2\"}}]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eparams\u003c/code\u003e必须与 pages 文件夹 中的文件名称对应\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果 page 文件名称是\u003ccode\u003epages/posts/[postId]/[commentId]\u003c/code\u003e，\u003ccode\u003eparams\u003c/code\u003e必须含有\u003ccode\u003epostId\u003c/code\u003e与\u003ccode\u003ecommentId\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e如果使用类数组路由, page 文件名称是\u003ccode\u003epages/posts/[...slug]\u003c/code\u003e，\u003ccode\u003eparams\u003c/code\u003e必须包含一个\u003ccode\u003eslug\u003c/code\u003e的数组\u003c/li\u003e\n\u003cli\u003e如果使用可选类数组路由，可以使用 \u003ccode\u003enull\u003c/code\u003e, \u003ccode\u003e[]\u003c/code\u003e, \u003ccode\u003eundefined\u003c/code\u003e 或 \u003ccode\u003efalse\u003c/code\u003e 渲染根路由。例如，对于\u003ccode\u003epages/[[...slug]]\u003c/code\u003e,如果\u003ccode\u003eslug: false\u003c/code\u003e,会渲染/页面\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003efallback\u003c/code\u003e必填项，访问路径不存在时的处理情况\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efallback: false\u003c/code\u003e：如果当前访问路径不在\u003ccode\u003epaths\u003c/code\u003e对象中,访问404页面。每次添加新页面时，都需要重新打包\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efallback: true\u003c/code\u003e：访问路径不在\u003ccode\u003epaths\u003c/code\u003e中不会导致404，Next.js 前端会创建一个\u003ccode\u003efallback\u003c/code\u003e版本以供使用，在后端重新走一遍\u003ccode\u003egetStaticPaths\u003c/code\u003e，重新创建一个对应访问路径页面，并放到预渲染\u003ccode\u003epaths\u003c/code\u003e对象中以供以后使用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efallback:blocking\u003c/code\u003e：访问路径不在\u003ccode\u003epaths\u003c/code\u003e中不会导致404，Next.js 会通过服务端渲染\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFallback pages\u003c/p\u003e\n\u003cp\u003e在\u003ccode\u003efallback\u003c/code\u003e版本时，\u003ccode\u003epage\u003c/code\u003e的\u003ccode\u003eprops\u003c/code\u003e为空,如果使用\u003ccode\u003enext/router\u003c/code\u003e,\u003ccode\u003erouter.isFallback\u003c/code\u003e是\u003ccode\u003etrue\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003ePost\u003c/span\u003e = (\u003cspan\u003e{ data }\u003c/span\u003e) =\u003e {\n  \u003cspan\u003econst\u003c/span\u003e router = \u003cspan\u003euseRouter\u003c/span\u003e()\n  \u003cspan\u003eif\u003c/span\u003e (router.\u003cspan\u003eisFallback\u003c/span\u003e) {\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u003cspan\u003e\u0026#x3C;\u003cspan\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eLoading...\u003cspan\u003e\u0026#x3C;/\u003cspan\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  }\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u003cspan\u003e\u0026#x3C;\u003cspan\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e{data}page\u003cspan\u003e\u0026#x3C;/\u003cspan\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003easync\u003c/span\u003e \u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003egetStaticPaths\u003c/span\u003e(\u003cspan\u003e\u003c/span\u003e) {\n  \u003cspan\u003ereturn\u003c/span\u003e {\n    \u003cspan\u003epaths\u003c/span\u003e: [\n      {\n        \u003cspan\u003eparams\u003c/span\u003e: {\n          \u003cspan\u003eid\u003c/span\u003e: \u003cspan\u003e'1'\u003c/span\u003e,\n        },\n      },\n    ],\n    \u003cspan\u003efallback\u003c/span\u003e: \u003cspan\u003etrue\u003c/span\u003e,\n  }\n}\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003easync\u003c/span\u003e \u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003egetStaticProps\u003c/span\u003e(\u003cspan\u003econtext\u003c/span\u003e) {\n  \u003cspan\u003econst\u003c/span\u003e id = context.\u003cspan\u003eparams\u003c/span\u003e.\u003cspan\u003eid\u003c/span\u003e\n  \u003cspan\u003ereturn\u003c/span\u003e {\n    \u003cspan\u003eprops\u003c/span\u003e: {\n      \u003cspan\u003edata\u003c/span\u003e: id,\n    },\n    \u003cspan\u003erevalidate\u003c/span\u003e: \u003cspan\u003etrue\u003c/span\u003e,\n  }\n}\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003edefault\u003c/span\u003e \u003cspan\u003ePost\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5 id=\"user-content-服务端渲染-server-side-rendering\"\u003e\u003ca href=\"#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93-server-side-rendering\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e服务端渲染 Server-side Rendering\u003c/h5\u003e\n\u003cp\u003e\u003cstrong\u003e服务端渲染\u003c/strong\u003e在每个请求都会根据内容重新生成页面\u003c/p\u003e\n\u003cp\u003e类似\u003ccode\u003egetStaticProps\u003c/code\u003e,可以使用\u003ccode\u003egetServerSideProps\u003c/code\u003e返回一个props对象,在每次请求时都会走一遍这个函数并重新生成页面\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eIndex\u003c/span\u003e = (\u003cspan\u003edata\u003c/span\u003e) =\u003e {\n  \u003cspan\u003e// {data.name}\u003c/span\u003e\n}\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003easync\u003c/span\u003e \u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003egetServerSideProps\u003c/span\u003e(\u003cspan\u003e\u003c/span\u003e) {\n  \u003cspan\u003elet\u003c/span\u003e data = {\n    \u003cspan\u003ename\u003c/span\u003e: \u003cspan\u003e'John'\u003c/span\u003e,\n  }\n  \u003cspan\u003ereturn\u003c/span\u003e {\n    \u003cspan\u003eprops\u003c/span\u003e: data,\n  }\n}\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003edefault\u003c/span\u003e \u003cspan\u003eIndex\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003egetServerSideProps(context):ReturnObject\u003c/code\u003e：用于服务端渲染的异步函数，返回一个props对象供 React 组件使用。同样的，不会在浏览器端代码出现该函数,并且只能在页面组件中使用这个函数，\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003easync\u003c/span\u003e \u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003egetServerSideProps\u003c/span\u003e(\u003cspan\u003econtext\u003c/span\u003e) {\n  \u003cspan\u003ereturn\u003c/span\u003e {\n    \u003cspan\u003eprops\u003c/span\u003e: {},\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003econtext\u003c/code\u003e：包含以下属性\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eparams\u003c/code\u003e：同\u003ccode\u003egetStaticProps\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ereq\u003c/code\u003e：请求对象\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eres\u003c/code\u003e：响应对象\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003equery\u003c/code\u003e：query string 的对象\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epreview\u003c/code\u003e：同\u003ccode\u003egetStaticProps\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epreviewData\u003c/code\u003e：同\u003ccode\u003egetStaticProps\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eresolvedUrl\u003c/code\u003e：请求URL的规范化版本\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elocale\u003c/code\u003e：同\u003ccode\u003egetStaticProps\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elocales\u003c/code\u003e：同\u003ccode\u003egetStaticProps\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edefaultLocale\u003c/code\u003e：同\u003ccode\u003egetStaticProps\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eReturnObject包含以下属性：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eprops\u003c/code\u003e：同\u003ccode\u003egetStaticProps\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enotFound\u003c/code\u003e：同\u003ccode\u003egetStaticProps\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eredirect\u003c/code\u003e：同\u003ccode\u003egetStaticProps\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5 id=\"user-content-增量静态生成-incremental-static-regeneration-\"\u003e\u003ca href=\"#%E5%A2%9E%E9%87%8F%E9%9D%99%E6%80%81%E7%94%9F%E6%88%90-incremental-static-regeneration-\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e增量静态生成 Incremental Static Regeneration ?\u003c/h5\u003e\n\u003cp\u003e感觉像动态部署，部署时不会导致服务切断。返回时添加一个\u003ccode\u003erevalidate: second\u003c/code\u003e表明在几秒之后重新部署\u003c/p\u003e\n\u003ch3 id=\"user-content-样式集成\"\u003e\u003ca href=\"#%E6%A0%B7%E5%BC%8F%E9%9B%86%E6%88%90\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e样式集成\u003c/h3\u003e\n\u003ch4 id=\"user-content-全局样式\"\u003e\u003ca href=\"#%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e全局样式\u003c/h4\u003e\n\u003cp\u003e创建文件\u003ccode\u003epages/_app.js\u003c/code\u003e，在该文件中的样式会在所有页面和组件中生效\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// _app.js\u003c/span\u003e\n\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003e'../styles.css'\u003c/span\u003e\n\n\u003cspan\u003e// This default export is required in a new `pages/_app.js` file.\u003c/span\u003e\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003edefault\u003c/span\u003e \u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003eMyApp\u003c/span\u003e(\u003cspan\u003e{ Component, pageProps }\u003c/span\u003e) {\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u003cspan\u003e\u0026#x3C;\u003cspan\u003eComponent\u003c/span\u003e {\u003cspan\u003e...pageProps\u003c/span\u003e} /\u003e\u003c/span\u003e\u003c/span\u003e\n}\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"user-content-范围样式\"\u003e\u003ca href=\"#%E8%8C%83%E5%9B%B4%E6%A0%B7%E5%BC%8F\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e范围样式\u003c/h4\u003e\n\u003cp\u003eNext.js 支持\u003ca href=\"https://github.com/css-modules/css-modules\"\u003eCSS Modules\u003c/a\u003e 为每个组件赋予独立的样式。命名为\u003ccode\u003e[name].module.css\u003c/code\u003e。会在每个\u003ccode\u003eclass\u003c/code\u003e后添加一个 Hash 值\u003c/p\u003e\n\u003ch4 id=\"user-content-sass-支持\"\u003e\u003ca href=\"#sass-%E6%94%AF%E6%8C%81\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003eSass 支持\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003enpm install sass\u003c/code\u003e即可在项目中使用 sass 或 scss\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e自定义 Sass 配置\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e可以通过在\u003ccode\u003enext.config.js\u003c/code\u003e中的\u003ccode\u003esassOptions\u003c/code\u003e对 sass 进行配置\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003econst\u003c/span\u003e path = \u003cspan\u003erequire\u003c/span\u003e(\u003cspan\u003e'path'\u003c/span\u003e)\n\n\u003cspan\u003emodule\u003c/span\u003e.\u003cspan\u003eexports\u003c/span\u003e = {\n  \u003cspan\u003esassOptions\u003c/span\u003e: {\n    \u003cspan\u003eincludePaths\u003c/span\u003e: [path.\u003cspan\u003ejoin\u003c/span\u003e(__dirname, \u003cspan\u003e'styles'\u003c/span\u003e)],\n  },\n}\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"user-content-css-in-js\"\u003e\u003ca href=\"#css-in-js\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003eCSS-in-JS\u003c/h4\u003e\n\u003cp\u003e基本上和create-react-app一样，Next.js 内置了\u003ca href=\"https://github.com/vercel/styled-jsx\"\u003estyled-jsx\u003c/a\u003e。实现\u003ca\u003estyled-component\u003c/a\u003e和\u003ca href=\"https://emotion.sh/docs/introduction\"\u003eemotion\u003c/a\u003e的效果\u003c/p\u003e\n\u003ch3 id=\"user-content-图形组件与优化\"\u003e\u003ca href=\"#%E5%9B%BE%E5%BD%A2%E7%BB%84%E4%BB%B6%E4%B8%8E%E4%BC%98%E5%8C%96\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e图形组件与优化\u003c/h3\u003e\n\u003cp\u003eNext.js 提供了与Gatsby一样优化很棒的图像组件\u003ccode\u003enext/image\u003c/code\u003e，\u003ccode\u003eImage\u003c/code\u003e支持常见的懒加载，resize，以现代格式显示图片等功能。\u003c/p\u003e\n\u003ch4 id=\"user-content-配置\"\u003e\u003ca href=\"#%E9%85%8D%E7%BD%AE\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e配置\u003c/h4\u003e\n\u003cp\u003e可以在\u003ccode\u003enext.config.js\u003c/code\u003e配置images获得最优化的效果\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e支持外部网站\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e加载一个外部网站托管的图片，在\u003ccode\u003enext.config.js\u003c/code\u003e中配置\u003ccode\u003eimages\u003c/code\u003e的\u003ccode\u003edomains\u003c/code\u003e字段\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e自定义加载器\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eNext.js  可以自定义自己的图形加载器，通过配置\u003ccode\u003eimages\u003c/code\u003e的\u003ccode\u003eloader\u003c/code\u003e字段\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e缓存\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eNext.js 默认会将访问过的图片缓存至\u003ccode\u003e\u0026#x3C;distDir\u003e/cache/images\u003c/code\u003e文件夹。缓存时间有服务端的\u003ccode\u003eCache-Control\u003c/code\u003e字段控制：\u003ccode\u003es-maxage||max-age||60s\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003emodule\u003c/span\u003e.\u003cspan\u003eexports\u003c/span\u003e = {\n  \u003cspan\u003eimages\u003c/span\u003e: {\n    \u003cspan\u003e// 外部域名\u003c/span\u003e\n    \u003cspan\u003edomains\u003c/span\u003e: [\u003cspan\u003e'example.com'\u003c/span\u003e],\n    \u003cspan\u003e// 自定义加载器\u003c/span\u003e\n   \t\u003cspan\u003eloader\u003c/span\u003e: \u003cspan\u003e'imgix'\u003c/span\u003e,\n    \u003cspan\u003epath\u003c/span\u003e: \u003cspan\u003e'https://example.com/myaccount/'\u003c/span\u003e,\n  },\n}\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"user-content-静态文件托管\"\u003e\u003ca href=\"#%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E6%89%98%E7%AE%A1\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e静态文件托管\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003epublic\u003c/code\u003e文件夹下的文件会作为 Next.js 的静态文件夹。可以通过URL\u003ccode\u003e/\u003c/code\u003e进行访问\u003c/p\u003e\n\u003ch2 id=\"user-content-路由\"\u003e\u003ca href=\"#%E8%B7%AF%E7%94%B1\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e路由\u003c/h2\u003e\n\u003cp\u003e正如上文所说，Next.js 在\u003ccode\u003epages\u003c/code\u003e文件夹下的每个文件都是一个路由，路由名称与文件目录相同\u003c/p\u003e\n\u003ch4 id=\"user-content-路由规则\"\u003e\u003ca href=\"#%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e路由规则\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epages/index.js\u003c/code\u003e → \u003ccode\u003e/\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epages/blog/index.js\u003c/code\u003e → \u003ccode\u003e/blog\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epages/blog/first-post.js\u003c/code\u003e → \u003ccode\u003e/blog/first-post\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epages/dashboard/settings/username.js\u003c/code\u003e → \u003ccode\u003e/dashboard/settings/username\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e路由动态切片\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e可以使用大括号语法定义一个切片路由\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epages/blog/[slug].js\u003c/code\u003e → \u003ccode\u003e/blog/:slug\u003c/code\u003e (\u003ccode\u003e/blog/hello-world\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epages/[username]/settings.js\u003c/code\u003e → \u003ccode\u003e/:username/settings\u003c/code\u003e (\u003ccode\u003e/foo/settings\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epages/post/[...all].js\u003c/code\u003e → \u003ccode\u003e/post/*\u003c/code\u003e (\u003ccode\u003e/post/2020/id/title\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"user-content-动态路由\"\u003e\u003ca href=\"#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e动态路由\u003c/h3\u003e\n\u003cp\u003e在一些app中，比如博客系统，路由的路径很难预先定义，可以在pages文件夹下设置方括号定义动态路由，例如\u003ccode\u003epages/post/[id].js\u003c/code\u003e, 会匹配任何类似\u003ccode\u003e/post/1\u003c/code\u003e,\u003ccode\u003e/post/a\u003c/code\u003e的路由\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e { useRouter } \u003cspan\u003efrom\u003c/span\u003e \u003cspan\u003e'next/router'\u003c/span\u003e\n\n\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003ePost\u003c/span\u003e = (\u003cspan\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan\u003econst\u003c/span\u003e router = \u003cspan\u003euseRouter\u003c/span\u003e()\n  \u003cspan\u003econst\u003c/span\u003e { pid } = router.\u003cspan\u003equery\u003c/span\u003e\n\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u003cspan\u003e\u0026#x3C;\u003cspan\u003ep\u003c/span\u003e\u003e\u003c/span\u003ePost: {pid}\u003cspan\u003e\u0026#x3C;/\u003cspan\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003edefault\u003c/span\u003e \u003cspan\u003ePost\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"user-content-路由跳转\"\u003e\u003ca href=\"#%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e路由跳转\u003c/h4\u003e\n\u003cp\u003e通过\u003ccode\u003enext/link\u003c/code\u003e的\u003ccode\u003eLink\u003c/code\u003e组件,允许浏览器端跳转页面\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eLink\u003c/span\u003e \u003cspan\u003efrom\u003c/span\u003e \u003cspan\u003e'next/link'\u003c/span\u003e\n\u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003eHome\u003c/span\u003e(\u003cspan\u003e\u003c/span\u003e) {\n  \u003cspan\u003ereturn\u003c/span\u003e (\n    \u003cspan\u003e\u003cspan\u003e\u0026#x3C;\u003e\u003c/span\u003e\n      \u003cspan\u003e\u0026#x3C;\u003cspan\u003eLink\u003c/span\u003e \u003cspan\u003ehref\u003c/span\u003e=\u003cspan\u003e\"/home\"\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan\u003e\u0026#x3C;\u003cspan\u003ea\u003c/span\u003e\u003e\u003c/span\u003eHome\u003cspan\u003e\u0026#x3C;/\u003cspan\u003ea\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan\u003e\u0026#x3C;/\u003cspan\u003eLink\u003c/span\u003e\u003e\u003c/span\u003e\n    \t\u003cspan\u003e\u0026#x3C;\u003cspan\u003eLink\u003c/span\u003e \u003cspan\u003ehref\u003c/span\u003e=\u003cspan\u003e{\u003c/span\u003e`/\u003cspan\u003eblog\u003c/span\u003e/${\u003cspan\u003eencodeURIComponent\u003c/span\u003e(\u003cspan\u003epost.slug\u003c/span\u003e)}`}\u003e\u003c/span\u003e\n        \u003cspan\u003e\u0026#x3C;\u003cspan\u003ea\u003c/span\u003e\u003e\u003c/span\u003e{post.title}\u003cspan\u003e\u0026#x3C;/\u003cspan\u003ea\u003c/span\u003e\u003e\u003c/span\u003e\n\t\t\t\u003cspan\u003e\u0026#x3C;/\u003cspan\u003eLink\u003c/span\u003e\u003e\u003c/span\u003e\n    // href 对象,pathname表明文件所在路径 \n      \u003cspan\u003e\u0026#x3C;\u003cspan\u003eLink\u003c/span\u003e\n        \u003cspan\u003ehref\u003c/span\u003e=\u003cspan\u003e{{\u003c/span\u003e\n          \u003cspan\u003epathname:\u003c/span\u003e '/\u003cspan\u003eblog\u003c/span\u003e/[\u003cspan\u003eslug\u003c/span\u003e]',\n          \u003cspan\u003equery:\u003c/span\u003e { \u003cspan\u003eslug:\u003c/span\u003e \u003cspan\u003epost.slug\u003c/span\u003e },\n        }}\n      \u003e\u003c/span\u003e\n        \u003cspan\u003e\u0026#x3C;\u003cspan\u003ea\u003c/span\u003e\u003e\u003c/span\u003e{post.title}\u003cspan\u003e\u0026#x3C;/\u003cspan\u003ea\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan\u003e\u0026#x3C;/\u003cspan\u003eLink\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"user-content-捕获所有路由\"\u003e\u003ca href=\"#%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E8%B7%AF%E7%94%B1\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e捕获所有路由\u003c/h4\u003e\n\u003cp\u003e可以在方括号中添加拓展运算符\u003ccode\u003e...\u003c/code\u003e捕获所有路由\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epages/post/[...slug].js\u003c/code\u003e匹配\u003ccode\u003e/post/a\u003c/code\u003e,\u003ccode\u003e/post/a/b\u003c/code\u003e。这种情况下, \u003ccode\u003erouter.query\u003c/code\u003e的\u003ccode\u003eslug\u003c/code\u003e会是一个数组\u003ccode\u003e['a','b']\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eOptional 捕获所有路由\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epages\u003c/code\u003e文件夹名称是双括号包裹的话，可以匹配根路由。\u003ccode\u003epages/post/[[...slug]].js\u003c/code\u003e可以匹配\u003ccode\u003e/post\u003c/code\u003e,\u003ccode\u003e/post/a\u003c/code\u003e,\u003ccode\u003e/post/a/b\u003c/code\u003e\u003c/p\u003e\n\u003ch4 id=\"user-content-路由注入\"\u003e\u003ca href=\"#%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%85%A5\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e路由注入\u003c/h4\u003e\n\u003cp\u003e使用\u003ccode\u003euseRouter\u003c/code\u003e hook进行路由注入,命令式的跳转路由\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// post/aa\u0026#x26;name=bb\u003c/span\u003e\n\u003cspan\u003eimport\u003c/span\u003e { useRouter } \u003cspan\u003efrom\u003c/span\u003e \u003cspan\u003e'next/router'\u003c/span\u003e\n\u003cspan\u003econst\u003c/span\u003e router = \u003cspan\u003euseRouter\u003c/span\u003e()\n\u003cspan\u003econst\u003c/span\u003e { pid } = router.\u003cspan\u003equery\u003c/span\u003e\t\u003cspan\u003e// {pid:'aa', name:'bb'}\u003c/span\u003e\n\u0026#x3C;span onClick={\u003cspan\u003e() =\u003e\u003c/span\u003e router.\u003cspan\u003epush\u003c/span\u003e(\u003cspan\u003e'/about'\u003c/span\u003e)}\u003e\u003cspan\u003eClick\u003c/span\u003e here to read more\u0026#x3C;/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"user-content-浅层路由\"\u003e\u003ca href=\"#%E6%B5%85%E5%B1%82%E8%B7%AF%E7%94%B1\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e浅层路由\u003c/h4\u003e\n\u003cp\u003e浅层路由允许你在不加载具体页面内容的前提下，修改路由。不知道有啥用\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e { useEffect } \u003cspan\u003efrom\u003c/span\u003e \u003cspan\u003e'react'\u003c/span\u003e\n\u003cspan\u003eimport\u003c/span\u003e { useRouter } \u003cspan\u003efrom\u003c/span\u003e \u003cspan\u003e'next/router'\u003c/span\u003e\n\u003cspan\u003econst\u003c/span\u003e router = \u003cspan\u003euseRouter\u003c/span\u003e()\n\u003cspan\u003euseEffect\u003c/span\u003e(\u003cspan\u003e() =\u003e\u003c/span\u003e {\n   router.\u003cspan\u003epush\u003c/span\u003e(\u003cspan\u003e'/?counter=10'\u003c/span\u003e, \u003cspan\u003eundefined\u003c/span\u003e, { \u003cspan\u003eshallow\u003c/span\u003e: \u003cspan\u003etrue\u003c/span\u003e })\n}, [])\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"user-content-打包部署\"\u003e\u003ca href=\"#%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e打包部署\u003c/h3\u003e\n\u003ch3 id=\"user-content-typescript集成\"\u003e\u003ca href=\"#typescript%E9%9B%86%E6%88%90\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003eTypeScript集成\u003c/h3\u003e\n\u003cp\u003e创建\u003ccode\u003etsconfig.json\u003c/code\u003e，\u003ccode\u003eyarn add --dev typescript @types/react @types/node\u003c/code\u003e即可在 Next.js 中使用 typescript\u003c/p\u003e\n\u003ch4 id=\"user-content-常见的渲染方法\"\u003e\u003ca href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B8%B2%E6%9F%93%E6%96%B9%E6%B3%95\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e常见的渲染方法\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e { \u003cspan\u003eGetStaticProps\u003c/span\u003e, \u003cspan\u003eGetStaticPaths\u003c/span\u003e, \u003cspan\u003eGetServerSideProps\u003c/span\u003e } \u003cspan\u003efrom\u003c/span\u003e \u003cspan\u003e'next'\u003c/span\u003e\n\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003egetStaticProps\u003c/span\u003e: \u003cspan\u003eGetStaticProps\u003c/span\u003e = \u003cspan\u003easync\u003c/span\u003e (context) =\u003e {\n  \u003cspan\u003e// ...\u003c/span\u003e\n}\n\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003egetStaticPaths\u003c/span\u003e: \u003cspan\u003eGetStaticPaths\u003c/span\u003e = \u003cspan\u003easync\u003c/span\u003e () =\u003e {\n  \u003cspan\u003e// ...\u003c/span\u003e\n}\n\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003egetServerSideProps\u003c/span\u003e: \u003cspan\u003eGetServerSideProps\u003c/span\u003e = \u003cspan\u003easync\u003c/span\u003e (context) =\u003e {\n  \u003cspan\u003e// ...\u003c/span\u003e\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果想要在 React 组件中的 props引用类型，可以使用\u003ccode\u003eInferGetStaticPropsType\u0026#x3C;typeof getStaticProps\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e { \u003cspan\u003eInferGetStaticPropsType\u003c/span\u003e } \u003cspan\u003efrom\u003c/span\u003e \u003cspan\u003e'next'\u003c/span\u003e\n\n\u003cspan\u003etype\u003c/span\u003e \u003cspan\u003ePost\u003c/span\u003e = {\n  \u003cspan\u003eauthor\u003c/span\u003e: \u003cspan\u003estring\u003c/span\u003e\n  \u003cspan\u003econtent\u003c/span\u003e: \u003cspan\u003estring\u003c/span\u003e\n}\n\n\u003cspan\u003e// 这种情况就不需要使用 GetStaticProps，InferGetStaticPropsType 会自动生成 props 类型\u003c/span\u003e\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003egetStaticProps\u003c/span\u003e = \u003cspan\u003easync\u003c/span\u003e (\u003cspan\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan\u003econst\u003c/span\u003e res = \u003cspan\u003eawait\u003c/span\u003e \u003cspan\u003efetch\u003c/span\u003e(\u003cspan\u003e'https://.../posts'\u003c/span\u003e)\n  \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eposts\u003c/span\u003e: \u003cspan\u003ePost\u003c/span\u003e[] = \u003cspan\u003eawait\u003c/span\u003e res.\u003cspan\u003ejson\u003c/span\u003e()\n\n  \u003cspan\u003ereturn\u003c/span\u003e {\n    \u003cspan\u003eprops\u003c/span\u003e: {\n      posts,\n    },\n  }\n}\n\n\u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003eBlog\u003c/span\u003e(\u003cspan\u003e{ posts }: InferGetStaticPropsType\u0026#x3C;\u003cspan\u003etypeof\u003c/span\u003e getStaticProps\u003e\u003c/span\u003e) {\n  \u003cspan\u003e// will resolve posts to type Post[]\u003c/span\u003e\n}\n\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003edefault\u003c/span\u003e \u003cspan\u003eBlog\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"user-content-api-路由\"\u003e\u003ca href=\"#api-%E8%B7%AF%E7%94%B1\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003eAPI 路由\u003c/h4\u003e\n\u003cp\u003e在\u003ccode\u003epages/api\u003c/code\u003e中可以自定义一些接口\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003etype\u003c/span\u003e { \u003cspan\u003eNextApiRequest\u003c/span\u003e, \u003cspan\u003eNextApiResponse\u003c/span\u003e } \u003cspan\u003efrom\u003c/span\u003e \u003cspan\u003e'next'\u003c/span\u003e\n\n\u003cspan\u003etype\u003c/span\u003e \u003cspan\u003eData\u003c/span\u003e = {\n  \u003cspan\u003ename\u003c/span\u003e: \u003cspan\u003estring\u003c/span\u003e\n}\n\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003edefault\u003c/span\u003e (\u003cspan\u003ereq\u003c/span\u003e: \u003cspan\u003eNextApiRequest\u003c/span\u003e, \u003cspan\u003eres\u003c/span\u003e: \u003cspan\u003eNextApiResponse\u003c/span\u003e\u0026#x3C;\u003cspan\u003eData\u003c/span\u003e\u003e) =\u003e {\n  res.\u003cspan\u003estatus\u003c/span\u003e(\u003cspan\u003e200\u003c/span\u003e).\u003cspan\u003ejson\u003c/span\u003e({ \u003cspan\u003ename\u003c/span\u003e: \u003cspan\u003e'John Doe'\u003c/span\u003e })\n}\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"user-content-custom-app\"\u003e\u003ca href=\"#custom-app\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003eCustom \u003ccode\u003eApp\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003e比如在\u003ccode\u003e_app.tsx\u003c/code\u003e中自定义 App 组件\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// import App from \"next/app\";\u003c/span\u003e\n\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003etype\u003c/span\u003e { \u003cspan\u003eAppProps\u003c/span\u003e \u003cspan\u003e/*, AppContext */\u003c/span\u003e } \u003cspan\u003efrom\u003c/span\u003e \u003cspan\u003e'next/app'\u003c/span\u003e\n\n\u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003eMyApp\u003c/span\u003e(\u003cspan\u003e{ Component, pageProps }: AppProps\u003c/span\u003e) {\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u003cspan\u003e\u0026#x3C;\u003cspan\u003eComponent\u003c/span\u003e {\u003cspan\u003e...pageProps\u003c/span\u003e} /\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\n\u003cspan\u003e// Only uncomment this method if you have blocking data requirements for\u003c/span\u003e\n\u003cspan\u003e// every single page in your application. This disables the ability to\u003c/span\u003e\n\u003cspan\u003e// perform automatic static optimization, causing every page in your app to\u003c/span\u003e\n\u003cspan\u003e// be server-side rendered.\u003c/span\u003e\n\u003cspan\u003e//\u003c/span\u003e\n\u003cspan\u003e// MyApp.getInitialProps = async (appContext: AppContext) =\u003e {\u003c/span\u003e\n\u003cspan\u003e//   // calls page's `getInitialProps` and fills `appProps.pageProps`\u003c/span\u003e\n\u003cspan\u003e//   const appProps = await App.getInitialProps(appContext);\u003c/span\u003e\n\n\u003cspan\u003e//   return { ...appProps }\u003c/span\u003e\n\u003cspan\u003e// }\u003c/span\u003e\n\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003edefault\u003c/span\u003e \u003cspan\u003eMyApp\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"user-content-环境变量\"\u003e\u003ca href=\"#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e环境变量\u003c/h3\u003e\n\u003cp\u003e可以在项目根目录添加\u003ccode\u003e.env/*\u003c/code\u003e配置环境变量,其中\u003ccode\u003e.env\u003c/code\u003e和\u003ccode\u003e.env.local\u003c/code\u003e会作为默认配置，\u003ccode\u003e.env.development\u003c/code\u003e会作为开发环境的变量, \u003ccode\u003e.env.production\u003c/code\u003e会作为生产环境的变量设置\u003c/p\u003e\n\u003cp\u003e环境变量中的变量可以通过\u003ccode\u003e$\u003c/code\u003e访问之前的变量\u003c/p\u003e\n\u003cp\u003e环境变量只能被\u003ccode\u003enode\u003c/code\u003e环境使用,如果想在浏览器端使用环境变量，需要在变量名前添加\u003ccode\u003eNEXT_PUBLIC_\u003c/code\u003e前缀\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e# .env\u003c/span\u003e\nHOSTNAME=localhost\nPORT=8080\nHOST=http://\u003cspan\u003e$HOSTNAME\u003c/span\u003e:\u003cspan\u003e$PORT\u003c/span\u003e\nNEXT_PUBLIC_ANALYTICS_ID=abcdefghijk\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"user-content-api-路由-1\"\u003e\u003ca href=\"#api-%E8%B7%AF%E7%94%B1-1\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003eAPI 路由\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003epages/api/*\u003c/code\u003e中的文件会作为 api 接口而不是作为页面使用\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// pages/api/hello\u003c/span\u003e\n\u003cspan\u003eexport\u003c/span\u003e \u003cspan\u003edefault\u003c/span\u003e \u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003ehandler\u003c/span\u003e(\u003cspan\u003ereq, res\u003c/span\u003e) {\n  res.\u003cspan\u003estatus\u003c/span\u003e(\u003cspan\u003e200\u003c/span\u003e).\u003cspan\u003ejson\u003c/span\u003e({ \u003cspan\u003ename\u003c/span\u003e: \u003cspan\u003e'John Doe'\u003c/span\u003e })\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e访问\u003ccode\u003e/api/hello\u003c/code\u003e会返回一个 json 字符串\u003c/p\u003e\n\u003cp\u003eAPI 路由也支持像 \u003ccode\u003epages\u003c/code\u003e那样的动态路由\u003c/p\u003e\n\u003ch4 id=\"user-content-api-中间件\"\u003e\u003ca href=\"#api-%E4%B8%AD%E9%97%B4%E4%BB%B6\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003eAPI 中间件\u003c/h4\u003e\n\u003cp\u003e目前没有在 Next 中使用过\u003c/p\u003e\n\u003ch3 id=\"user-content-高级特性\"\u003e\u003ca href=\"#%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e高级特性\u003c/h3\u003e\n\u003ch3 id=\"user-content-注意事项\"\u003e\u003ca href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e注意事项\u003c/h3\u003e\n\u003ch4 id=\"user-content-读取文件使用processcwd\"\u003e\u003ca href=\"#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8processcwd\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e读取文件使用\u003ccode\u003eprocess.cwd()\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eNext.js编译代码是在一个独立的文件夹，所以不能使用\u003ccode\u003e__dirname\u003c/code\u003e获取文件夹目录,\u003ccode\u003eprocess.cwd()\u003c/code\u003e返回 Next.js 执行的目录\u003c/p\u003e\n\u003ch4 id=\"user-content-getstaticpaths-和-getserversideprops不能同时使用\"\u003e\u003ca href=\"#getstaticpaths-%E5%92%8C-getserversideprops%E4%B8%8D%E8%83%BD%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e\u003ccode\u003egetStaticPaths\u003c/code\u003e 和 \u003ccode\u003egetServerSideProps\u003c/code\u003e不能同时使用\u003c/h4\u003e\n","title":"学习笔记 Next.JS使用教程","date":"2021-04-23T13:47:05.000Z","tag":"React, Next.js","category":"程序人生","cover":null,"description":"description"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"学习笔记 NextJS"},"buildId":"yk5Zpotj4p9R4XPv5qhw8","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>