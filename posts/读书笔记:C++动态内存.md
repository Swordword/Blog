---
title: 读书笔记:C++ 动态内存
date: 2021-03-25 13:39:08
description: 即使在学C++之前，对它内存的double free和早泄也早有耳闻。。。
tag: Cpp
---

### 内存概述

C++内存大致分成三种：静态内存、栈内存和堆内存(又叫内存空间)。静态内存用于保存在整个函数运行期间都一直存在的对象，如局部static对象，类static数据成员。栈内存保存的是在程序运行中存在一段时间的对象，如函数中的非 static 对象。堆内存用来存储动态分配的对象，及在程序运行时(通过new这样的代码)分配的对象，因为动态对象是我们控制生成的，所以我们必须显示的销毁他们

### 动态内存与智能指针

`new` 运算符在动态内存中为对象分配空间并返回一个指向该对象的指针；`delete` 运算符接受 `new` 出来的指针，销毁该对象，并释放与之关联的内存。

想要在正确的时间释放内存是很困难的，并且也没发现好的调试内存泄漏的方法，C++ 提供了两种智能指针管理动态对象，**`shared_ptr` 允许多个指针指向同一个对象**，**`unique_ptr` 每个指针和一个对象绑定**。

#### 智能指针 `shared_ptr`

1. 是个模版，所以也需要尖括号指明类型。`shared_ptr<int> pi`

2. 智能指针的使用与普通指针类似。 `if(pi && pi->empty()) *pi = 11;`

3. `pi.get()`返回 pi 保存的指针，`swap(p,q)` 交换p和q的指针

4. `make_shared<T>(arg)` 返回一个 shared_ptr，指向类型为T的对象，其中arg是该对象初始化的参数

   如 `shared_ptr<int> p = make_shared<int>(42);` `shared_ptr<string> q = make_shared<string>(10,'9');`

   `make_shared<T>p(q)` p 是 shared_ptr q 的拷贝，该操作会递增 q 中的计数器，q 的指针必须能转换为T*

5. 智能指针相较于动态内存的优势在于当指向该对象的最后一个 shared_ptr 被销毁时（ shared_ptr 使用的计数器由1转为0），shared_ptr会自动销毁该对象(通过类中的成员函数：析构函数)。

   其中判断是不是最后一个智能指针是通过shared_ptr关联的**引用计数**完成的，当我们试图拷贝一个shared_ptr 时（用一个新 shared_ptr 初始化shared_ptr、将 shared_ptr 作为参数传递给一个函数，以及将 shared_ptr 作为函数的返回值。。。），计数器就会递增，反之则递减。

   可以通过 `pi.use_count()` 查看当前智能指针的计数器

6. 

[未完待续...]

