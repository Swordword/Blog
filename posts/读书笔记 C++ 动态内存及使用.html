<!DOCTYPE html><html lang="zh-Hans"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><meta name="description" content="Learn how to build a personal website using Next.js"/><meta property="og:image" content="https://og-image.now.sh/Swordword&#x27;s%20blog.png?theme=light&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><meta name="og:title" content="Swordword&#x27;s blog"/><title>读书笔记 C++ 动态内存及使用</title><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/876d048b5dab7c28.css" as="style"/><link rel="stylesheet" href="/_next/static/css/876d048b5dab7c28.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-d0adf646434a14b2.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-7c48f75ce2db1491.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e272e05dd28ef959.js" defer=""></script><script src="/_next/static/chunks/130-b952c5d507d712ac.js" defer=""></script><script src="/_next/static/chunks/749-555cb8054e68346e.js" defer=""></script><script src="/_next/static/chunks/241-e8e3e8578555aa77.js" defer=""></script><script src="/_next/static/chunks/783-464c81cbfd42177e.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-4108770bd2d21ccc.js" defer=""></script><script src="/_next/static/N-OKAoxaKmOR4Qwc77KAc/_buildManifest.js" defer=""></script><script src="/_next/static/N-OKAoxaKmOR4Qwc77KAc/_ssgManifest.js" defer=""></script></head><body><div id="__next"><style data-emotion="css dbbey5">.css-dbbey5{width:100vw;height:100vh;overflow-y:scroll;background:#eee;color:#3c4858;padding-bottom:50px;}</style><div class="css-dbbey5"><style data-emotion="css gpj3uu">.css-gpj3uu{width:100%;height:50px;color:#fff;background-color:rgba(47,65,84,0.7);box-shadow:0 2px 5px 0 rgb(0 0 0 / 16%),0 2px 10px 0 rgb(0 0 0 / 12%);position:fixed;top:0;left:0;z-index:2;}</style><div class="css-gpj3uu"><style data-emotion="css qjodyr">.css-qjodyr{width:1100px;height:100%;margin:auto;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><div class="css-qjodyr"><a href="/"><style data-emotion="css 19m5m0c">.css-19m5m0c{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:start;-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;}</style><div class="css-19m5m0c"><style data-emotion="css l2tq7e">.css-l2tq7e{width:30px;height:30px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><div class="css-l2tq7e"><style data-emotion="css brme6v">.css-brme6v{width:24px;height:24px;margin-left:6px;}</style><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-sword"></use></svg></div><style data-emotion="css 879ic9">.css-879ic9{margin-left:20px;}</style><div class="css-879ic9">Swordword</div></div></a><style data-emotion="css fhxb3m">.css-fhxb3m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><div class="css-fhxb3m"><a href="/"><style data-emotion="css kfc5ms">.css-kfc5ms{width:100px;height:50px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;}.css-kfc5ms:hover{color:#30A9DE;background-color:rgba(0,0,0,0.1);}</style><div class="css-kfc5ms"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-home"></use></svg></div><style data-emotion="css 1a2afmv">.css-1a2afmv{margin-left:10px;}</style><div class="css-1a2afmv">首页</div></div></a><style data-emotion="css 1lwiia1">.css-1lwiia1{width:100px;height:50px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;position:relative;}.css-1lwiia1:hover .nav-list{display:block;}</style><div class="css-1lwiia1"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-list"></use></svg></div><div class="css-1a2afmv">索引</div><style data-emotion="css su4vv2">.css-su4vv2{-webkit-transition:3s ease-out;transition:3s ease-out;display:none;width:100px;position:absolute;top:50px;left:0;background-color:rgba(47,65,84,0.7);box-shadow:0 2px 5px 0 rgb(0 0 0 / 16%),0 2px 10px 0 rgb(0 0 0 / 12%);}</style><div class="nav-list css-su4vv2"><a href="/archive"><div class="css-kfc5ms"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-guidang"></use></svg></div><div class="css-1a2afmv">归档</div></div></a><a href="/category"><div class="css-kfc5ms"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-leimupinleifenleileibie2"></use></svg></div><div class="css-1a2afmv">分类</div></div></a><a href="/tag"><div class="css-kfc5ms"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-tag1"></use></svg></div><div class="css-1a2afmv">标签</div></div></a></div></div><a href="/about"><div class="css-kfc5ms"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-lianhe4"></use></svg></div><div class="css-1a2afmv">关于</div></div></a><a href="/rss"><div class="css-kfc5ms"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-rss"></use></svg></div><div class="css-1a2afmv">RSS</div></div></a><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-OOjs_UI_icon_search-ltr"></use></svg></div><div class="css-1a2afmv"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-sun"></use></svg></div></div></div></div></div><style data-emotion="css 1739oy8">.css-1739oy8{z-index:1;}</style><div class="css-1739oy8"><style data-emotion="css z6d19t">.css-z6d19t{width:100%;height:350px;position:relative;background:url(/_next/static/media/banner.eb35a883.jpg) center;}</style><div class="css-z6d19t"></div></div><style data-emotion="css 3vwp2t">.css-3vwp2t{position:relative;width:1100px;background:#fff;padding:50px 100px;margin:-150px auto 50px;border-radius:8px;}</style><main class="css-3vwp2t"><article style="color:#3c4858"><style data-emotion="css yrjjfw">.css-yrjjfw{height:70px;margin:0;line-height:70px;text-align:center;font-size:40px;}</style><h1 class="css-yrjjfw">读书笔记 C++ 动态内存及使用</h1><style data-emotion="css faxeo3">.css-faxeo3{margin-left:250px;}</style><div class="css-faxeo3"><style data-emotion="css hc4w4d">.css-hc4w4d{height:40px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:start;-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><div class="css-hc4w4d"><style data-emotion="css 12qt3ml">.css-12qt3ml{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:start;-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><div class="css-12qt3ml"><style data-emotion="css 2ldgmb">.css-2ldgmb{color:#30a9de;}</style><small class="css-2ldgmb"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-time"></use></svg></div></small><style data-emotion="css qq1p72">.css-qq1p72{margin-left:10px;margin-right:20px;cursor:pointer;}</style><small class="css-qq1p72"><a href="/archive"><span><time dateTime="2021-03-25T13:39:08.000Z">21-03-25</time></span></a></small></div><div class="css-12qt3ml"><small class="css-2ldgmb"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-leimupinleifenleileibie2"></use></svg></div></small><small class="css-qq1p72"><a href="/category"><span>前往分类</span></a></small></div><div class="css-12qt3ml"><small class="css-2ldgmb"><div class="css-l2tq7e"><svg class="icon css-brme6v" aria-hidden="true"><use xlink:href="#icon-tag1"></use></svg></div></small><small class="css-qq1p72"><a href="/tag/cpp"><span>Cpp<!-- --> </span></a></small></div></div></div><style data-emotion="css h25mx1">.css-h25mx1{border-bottom:1px solid #30a9de;margin-top:20px;margin-bottom:20px;}</style><div class="css-h25mx1"></div><div><h3 id="user-content-内存概述"><a href="#%E5%86%85%E5%AD%98%E6%A6%82%E8%BF%B0" aria-hidden="true" tabindex="-1"><span></span></a>内存概述</h3>
<p>C++内存大致分成三种：静态内存、栈内存和堆内存(又叫内存空间)。静态内存用于保存在整个函数运行期间都一直存在的对象，如局部static对象，类static数据成员。栈内存保存的是在程序运行中存在一段时间的对象，如函数中的非 static 对象。堆内存用来存储动态分配的对象，及在程序运行时(通过new这样的代码)分配的对象，因为动态对象是我们控制生成的，所以我们必须显示的销毁他们</p>
<h3 id="user-content-动态内存与智能指针"><a href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88" aria-hidden="true" tabindex="-1"><span></span></a>动态内存与智能指针</h3>
<p><code>new</code> 运算符在动态内存中为对象分配空间并返回一个指向该对象的指针；<code>delete</code> 运算符接受 <code>new</code> 出来的指针，销毁该对象，并释放与之关联的内存。</p>
<p>想要在正确的时间释放内存是很困难的，并且也没发现好的调试内存泄漏的方法，C++ 提供了两种智能指针管理动态对象，<strong><code>shared_ptr</code> 允许多个指针指向同一个对象</strong>，<strong><code>unique_ptr</code> 每个指针和一个对象绑定</strong>。</p>
<h4 id="user-content-智能指针-shared_ptr"><a href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-shared_ptr" aria-hidden="true" tabindex="-1"><span></span></a>智能指针 <code>shared_ptr</code></h4>
<ol>
<li>
<p>是个模版，所以也需要尖括号指明类型。<code>shared_ptr&#x3C;int> pi</code></p>
<p>定义和改变<code>shared_ptr</code> 的其他方法</p>
<p>| 定义                                           | 说明                           |
| ---------------------------------------------- | ------------------------------ |
| shared_ptr  p(q) 、shared_ptr  p(u)      | p管理内置指针q所指向的对象     |
| shared_ptr  p(q, d)、shared_ptr  p(q, d) | 使用可调用对象代替默认的delete |</p>
</li>
<li>
<p>智能指针的使用与普通指针类似。 <code>if(pi &#x26;&#x26; pi->empty()) *pi = 11;</code></p>
</li>
<li>
<p><code>pi.get()</code>返回 pi 保存的指针，<code>swap(p,q)</code> 交换p和q的指针</p>
</li>
<li>
<p><code>make_shared&#x3C;T>(arg)</code> 返回一个 shared_ptr，指向类型为T的对象，其中arg是该对象初始化的参数</p>
<p>如 <code>shared_ptr&#x3C;int> p = make_shared&#x3C;int>(42);</code> <code>shared_ptr&#x3C;string> q = make_shared&#x3C;string>(10,'9');</code></p>
<p><code>make_shared&#x3C;T>p(q)</code> p 是 shared_ptr q 的拷贝，该操作会递增 q 中的计数器，q 的指针必须能转换为T*</p>
</li>
<li>
<p>智能指针相较于动态内存的优势在于当指向该对象的最后一个 shared_ptr 被销毁时（ shared_ptr 使用的计数器由1转为0），shared_ptr会自动销毁该对象(通过类中的成员函数：析构函数)。其中判断是不是最后一个智能指针是通过shared_ptr关联的<strong>引用计数</strong>完成的。</p>
</li>
<li>
<p>引用计数的计算方式</p>
<p>查看当前智能指针的计数器可以通过 <code>pi.use_count()</code>方法，</p>
<p>或者根据自己的经验。当我们试图拷贝一个shared_ptr 时，计数器就会递增，反之则递减。智能指针常见的拷贝情形如下</p>
<ul>
<li>用一个新 shared_ptr 初始化shared_ptr</li>
<li>将 shared_ptr 作为参数传递给一个函数</li>
<li>将 shared_ptr 作为函数的返回值</li>
</ul>
</li>
</ol>
<p>为什么要使用动态内存？</p>
<ol>
<li>程序不知道自己未来需要使用多少对象，如之前使用的容器类</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象见共享数据，即多个对象共享相同的状态，a销毁了，b紧连着也会被销毁</li>
</ol>
<h4 id="user-content-通过new和delete直接管理内存"><a href="#%E9%80%9A%E8%BF%87new%E5%92%8Cdelete%E7%9B%B4%E6%8E%A5%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98" aria-hidden="true" tabindex="-1"><span></span></a>通过<code>new</code>和<code>delete</code>直接管理内存</h4>
<p>在自由空间分配的内存是<strong>无名</strong>的，<code>new</code>返回一个指向该对象的指针</p>
<p><strong><code>new</code>初始化：</strong></p>
<ol>
<li>默认初始化	<code>string *ps = new string()</code></li>
<li>传统的构造方式（使用括号）  <code>string *ps = new string(10 , '9')</code></li>
<li>列表初始化  <code>vector&#x3C;int> *v = new vector&#x3C;int>{0,1,2,3}</code></li>
<li>对动态分配的值进行初始化    <code>string *ps = new string()</code></li>
</ol>
<p><strong>动态分配的 const 对象：</strong></p>
<p><code>const int *pci = new const int(1024)</code> 必须初始化返回一个指向const的指针</p>
<p><strong>防止内存耗尽抛出的异常：</strong></p>
<p>如果程序用光了可用的自由空间，<code>new</code> 默认会抛出类型为<code>bad_alloc</code>的异常，可以通过使用**定位<code>new</code>**的方式组织抛出异常</p>
<p><code>int *p1 = new int</code> 	// 分配失败，抛出<code>bad_alloc</code></p>
<p><code>int *p1 = new (nothrow) int</code> // 分配失败，返回一个空指针</p>
<p><strong>释放动态内存</strong>：</p>
<p>传递给<code>delete</code> 通过<code>new</code>获得的指针：销毁给定的指针指向的对象；释放对应的内存，<strong>有内置指针new管理的动态内存在显示释放之前都会一直存在</strong></p>
<p><strong>动态内存管理常见问题：</strong></p>
<ol>
<li>
<p>忘记<code>delete</code>内存，导致<strong>内存泄漏</strong></p>
</li>
<li>
<p>使用已经释放过的内存。可以通过释放内存后将指针置为空来解决</p>
<p>但是只能解决单一的指针，若多个指针指向同一个对象，就会导致别的指针无效</p>
<pre><code><span><span>int</span> *<span>p</span><span>(<span>new</span> <span>int</span>(<span>42</span>))</span></span>;	<span>// p指向动态内存</span>
<span>auto</span> q = p;		<span>// p和q指向相同的内存</span>
<span>delete</span> p;		<span>// p和q均无效</span>
p = <span>nullptr</span>;	<span>// 置空p，但是！q依然是一个指针，却无效了</span></code></pre>
</li>
<li>
<p>对同一块内存释放两次。</p>
</li>
</ol>
<p>**空悬指针：**指向一块曾经保存数据对象但是现在已经无效的内存的指针</p>
<p>当<code>delete</code>掉一个指针后，指针值就变为无效。但是很多机器仍然保存着（已经释放了的）动态内存的地址。导致 这个指针可能依然保存之前的值，但是它之后会变成什么样子已经不是你自己能控制的了，就像你把房子卖给了别人，下次再到这个地址看看，可能还是你的房子，也可能已经被改成公共厕所了。这种指针就叫做空悬指针</p>
<h4 id="user-content-shared_ptr和new结合使用"><a href="#shared_ptr%E5%92%8Cnew%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8" aria-hidden="true" tabindex="-1"><span></span></a><code>shared_ptr</code>和<code>new</code>结合使用</h4>
<p>接受指针参数的智能指针构造函数是explicit的（无法将内置指针隐式转换为一个智能指针），因此必须直接初始化一个智能指针</p>
<p><code>shared_ptr&#x3C;int> p1 = new int(1024)</code> 	// 错误 打算将 <code>new</code> 内置指针转换为智能指针</p>
<p><code>shared_ptr&#x3C;int> p1(new int(1024))</code></p>
<p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象。但是，如果我们<strong>提供自己的delete操作</strong>，我们<strong>可以将智能指针绑定到一个指向其他类型的资源的指针上</strong></p>
<p><strong>不要混合使用普通指针和智能指针</strong></p>
<pre><code><span><span>void</span> <span>process</span><span>(shared_ptr&#x3C;<span>int</span>> ptr)</span></span>{
} <span>// ptr 离开作用域，被销毁</span>

<span><span>int</span> *<span>x</span><span>(<span>new</span> <span>int</span>(<span>1024</span>))</span></span>; <span>// x 是一个普通指针，而不是一个智能指针</span>
<span>process</span>(x);	<span>// error shared_ptr 是explicit的</span>
<span>process</span>(<span>shared_ptr</span>&#x3C;<span>int</span>>(x))	<span>// 合法！但是 x 的内存会被释放，导致下一行的j获取不到值</span>
<span>int</span> j = *x;</code></pre>
<p><strong>不要使用get函数返回值初始化另一个智能指针或为指针指针赋值：</strong></p>
<p>智能指针的<code>get</code>函数返回一个内置指针，指向智能指针管理的对象。</p>
<p><code>get</code> 用来将指针的访问权限传递给代码，即只有在确保代码不会delete指针时，才能使用<code>get</code></p>
<pre><code><span>shared_ptr&#x3C;<span>int</span>> <span>p</span><span>(<span>new</span> <span>int</span>(<span>42</span>))</span></span>;
<span>int</span> *q = p.<span>get</span>();
{
	<span>shared_ptr</span>&#x3C;<span>int</span>>(q);
} <span>// 程序结束，q被销毁，指向的内存被释放，p为空悬指针</span>
<span>int</span> foo = *p;</code></pre>
<p><strong>shared_ptr 其他操作：</strong></p>
<p><code>shared_ptr.reset()</code> 将新指针赋予原先智能指针</p>
<p><code>shared_ptr.unique()</code> 检查自己是不是当前对象仅有的用户，即计数器是1</p>
<h4 id="user-content-使用智能指针优化程序异常"><a href="#%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E5%BC%82%E5%B8%B8" aria-hidden="true" tabindex="-1"><span></span></a>使用智能指针优化程序异常</h4>
<p>异常发生后，析构函数可能不会正常运行，使用智能指针，即使程序块提前结束，也会将多余的内存释放。</p>
<p><strong>智能指针使用规范：</strong></p>
<ul>
<li>不使用相同的内置指针初始化（或reset）多个智能指针</li>
<li>不delete get() 返回的指针</li>
<li>不使用get() 初始化或reset 另一个智能指针</li>
<li>使用 get() 返回的指针，当最后一个智能指针销毁时，内置指针成为悬空指针</li>
<li>当智能指针管理的不是new分配的内存，需要传递给一个删除器</li>
</ul>
<h4 id="user-content-unique_ptr使用"><a href="#unique_ptr%E4%BD%BF%E7%94%A8" aria-hidden="true" tabindex="-1"><span></span></a>unique_ptr使用</h4>
<p><code>unique_ptr</code> 与 给定对象一一对应， 因此不支持普通的拷贝和赋值操作</p>
<p>通过绑定到一个<code>new</code>返回的指针初始化， 没有类似 make_shared 的方法</p>
<p>可以通过调用<code>release</code> 或<code> reset</code> 将指针的所有权从 一个 <code>unique_ptr</code> 转移给另一个 <code>unique_ptr</code></p>
<pre><code><span>unique_ptr&#x3C;string> <span>p1</span> <span>(<span>new</span> string(<span>"Hello"</span>))</span></span>;
<span>unique_ptr&#x3C;string> <span>p2</span><span>(p1.release())</span></span>; <span>// 将所有权p1转向p2， release将 p1 置为空</span>
<span>unique_ptr&#x3C;string> <span>p3</span><span>(<span>new</span> string(<span>"world"</span>))</span>
p2.<span>reset</span><span>(p3.release())</span> <span>// reset 释放了原来 p2 指向的内存</span></span></code></pre>
<p><code>release</code>返回当前保存的指针并将其置为空。</p>
<p><code>reset</code>接受一个可选的指针参数，令<code>uniqeu_ptr</code>重新指向给定的指针。</p>
<p><strong>可以拷贝或赋值一个将要被销毁的unique_ptr</strong>. 例如从函数中返回一个<code>unique_ptr</code></p>
<pre><code><span>unique_ptr&#x3C;<span>int</span>> <span>clone</span><span>(<span>int</span> p)</span></span>{
  <span>return</span> <span>unique_ptr</span>&#x3C;<span>int</span>>(<span>new</span> <span>int</span>(p))
}</code></pre>
<p><strong>向 unique_ptr 传递删除器</strong></p>
<p>重载一个 unique_ptr 的删除器会影响到 unique_ptr类型并且决定如何构造该类型的对象，删除器必须在<strong>尖括号中指向类型之后提供删除器类型</strong></p>
<p><code>unique_ptr&#x3C;objT,delT p(new objT, fcn)>;</code></p>
<h4 id="user-content-weak_ptr"><a href="#weak_ptr" aria-hidden="true" tabindex="-1"><span></span></a>weak_ptr</h4>
<p><code>weak_ptr</code> ：不控制所指向对象生存期的智能指针
指向一个<code>shared_ptr</code>管理的对象，当其绑定到一个<code>shared_ptr</code> 上时，不会改变<code>shared_ptr</code>的引用计数.</p>
<p>| API               | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| weak_ptr w     | 空 weak_ptr，指向类型为T的对象                               |
| weak_ptr w(sp) | 与shared_ptr sp指向相同对象的weak_ptr. T可以转换为sp指向的类型 |
| w=p               | p可以是一个shared_ptr 或者 weak_ptr，w与p共享家对象          |
| w.reset()         | 将w置为空                                                    |
| w.use_count()     | 与w共享的shared_ptr 的计数器数量                             |
| w.expired()       | 若 w.use_count() 为0， 返回true。反之返回 false              |
| w.lock()          | 若 expired 为 true，返回一个空的shared_ptr,否则返回指向w的对象的 shared_ptr |</p>
<p>由于<code>weak_ptr</code> 指向的对象可能不存在，所以必须在使用前使用<code>wp.lock()</code>判断 weak_ptr 指向的对象是否存在</p>
<p><code>if(shared_ptr&#x3C;int> np = wp.lock()){}	// 如果np不为空则条件成立，wp对应了一个shared_ptr对象</code></p>
<p><code>weak_ptr</code>可以用来解决循环队列 <code>shared_ptr</code> 循环引用的问题。</p>
</div></article></main></div><style data-emotion="css 1st94pw">.css-1st94pw{text-align:center;height:30px;line-height:30px;color:#333;}</style><div class="css-1st94pw"><a href="https://beian.miit.gov.cn/" target="_blank" rel="noreferrer">京ICP备19054504号-2</a></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"读书笔记 C++ 动态内存及使用","contentHtml":"\u003ch3 id=\"user-content-内存概述\"\u003e\u003ca href=\"#%E5%86%85%E5%AD%98%E6%A6%82%E8%BF%B0\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e内存概述\u003c/h3\u003e\n\u003cp\u003eC++内存大致分成三种：静态内存、栈内存和堆内存(又叫内存空间)。静态内存用于保存在整个函数运行期间都一直存在的对象，如局部static对象，类static数据成员。栈内存保存的是在程序运行中存在一段时间的对象，如函数中的非 static 对象。堆内存用来存储动态分配的对象，及在程序运行时(通过new这样的代码)分配的对象，因为动态对象是我们控制生成的，所以我们必须显示的销毁他们\u003c/p\u003e\n\u003ch3 id=\"user-content-动态内存与智能指针\"\u003e\u003ca href=\"#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e动态内存与智能指针\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003enew\u003c/code\u003e 运算符在动态内存中为对象分配空间并返回一个指向该对象的指针；\u003ccode\u003edelete\u003c/code\u003e 运算符接受 \u003ccode\u003enew\u003c/code\u003e 出来的指针，销毁该对象，并释放与之关联的内存。\u003c/p\u003e\n\u003cp\u003e想要在正确的时间释放内存是很困难的，并且也没发现好的调试内存泄漏的方法，C++ 提供了两种智能指针管理动态对象，\u003cstrong\u003e\u003ccode\u003eshared_ptr\u003c/code\u003e 允许多个指针指向同一个对象\u003c/strong\u003e，\u003cstrong\u003e\u003ccode\u003eunique_ptr\u003c/code\u003e 每个指针和一个对象绑定\u003c/strong\u003e。\u003c/p\u003e\n\u003ch4 id=\"user-content-智能指针-shared_ptr\"\u003e\u003ca href=\"#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-shared_ptr\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e智能指针 \u003ccode\u003eshared_ptr\u003c/code\u003e\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e是个模版，所以也需要尖括号指明类型。\u003ccode\u003eshared_ptr\u0026#x3C;int\u003e pi\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e定义和改变\u003ccode\u003eshared_ptr\u003c/code\u003e 的其他方法\u003c/p\u003e\n\u003cp\u003e| 定义                                           | 说明                           |\n| ---------------------------------------------- | ------------------------------ |\n| shared_ptr  p(q) 、shared_ptr  p(u)      | p管理内置指针q所指向的对象     |\n| shared_ptr  p(q, d)、shared_ptr  p(q, d) | 使用可调用对象代替默认的delete |\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e智能指针的使用与普通指针类似。 \u003ccode\u003eif(pi \u0026#x26;\u0026#x26; pi-\u003eempty()) *pi = 11;\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003epi.get()\u003c/code\u003e返回 pi 保存的指针，\u003ccode\u003eswap(p,q)\u003c/code\u003e 交换p和q的指针\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003emake_shared\u0026#x3C;T\u003e(arg)\u003c/code\u003e 返回一个 shared_ptr，指向类型为T的对象，其中arg是该对象初始化的参数\u003c/p\u003e\n\u003cp\u003e如 \u003ccode\u003eshared_ptr\u0026#x3C;int\u003e p = make_shared\u0026#x3C;int\u003e(42);\u003c/code\u003e \u003ccode\u003eshared_ptr\u0026#x3C;string\u003e q = make_shared\u0026#x3C;string\u003e(10,'9');\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emake_shared\u0026#x3C;T\u003ep(q)\u003c/code\u003e p 是 shared_ptr q 的拷贝，该操作会递增 q 中的计数器，q 的指针必须能转换为T*\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e智能指针相较于动态内存的优势在于当指向该对象的最后一个 shared_ptr 被销毁时（ shared_ptr 使用的计数器由1转为0），shared_ptr会自动销毁该对象(通过类中的成员函数：析构函数)。其中判断是不是最后一个智能指针是通过shared_ptr关联的\u003cstrong\u003e引用计数\u003c/strong\u003e完成的。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e引用计数的计算方式\u003c/p\u003e\n\u003cp\u003e查看当前智能指针的计数器可以通过 \u003ccode\u003epi.use_count()\u003c/code\u003e方法，\u003c/p\u003e\n\u003cp\u003e或者根据自己的经验。当我们试图拷贝一个shared_ptr 时，计数器就会递增，反之则递减。智能指针常见的拷贝情形如下\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用一个新 shared_ptr 初始化shared_ptr\u003c/li\u003e\n\u003cli\u003e将 shared_ptr 作为参数传递给一个函数\u003c/li\u003e\n\u003cli\u003e将 shared_ptr 作为函数的返回值\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e为什么要使用动态内存？\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e程序不知道自己未来需要使用多少对象，如之前使用的容器类\u003c/li\u003e\n\u003cli\u003e程序不知道所需对象的准确类型\u003c/li\u003e\n\u003cli\u003e程序需要在多个对象见共享数据，即多个对象共享相同的状态，a销毁了，b紧连着也会被销毁\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"user-content-通过new和delete直接管理内存\"\u003e\u003ca href=\"#%E9%80%9A%E8%BF%87new%E5%92%8Cdelete%E7%9B%B4%E6%8E%A5%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e通过\u003ccode\u003enew\u003c/code\u003e和\u003ccode\u003edelete\u003c/code\u003e直接管理内存\u003c/h4\u003e\n\u003cp\u003e在自由空间分配的内存是\u003cstrong\u003e无名\u003c/strong\u003e的，\u003ccode\u003enew\u003c/code\u003e返回一个指向该对象的指针\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003enew\u003c/code\u003e初始化：\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e默认初始化\t\u003ccode\u003estring *ps = new string()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e传统的构造方式（使用括号）  \u003ccode\u003estring *ps = new string(10 , '9')\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e列表初始化  \u003ccode\u003evector\u0026#x3C;int\u003e *v = new vector\u0026#x3C;int\u003e{0,1,2,3}\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e对动态分配的值进行初始化    \u003ccode\u003estring *ps = new string()\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e动态分配的 const 对象：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003econst int *pci = new const int(1024)\u003c/code\u003e 必须初始化返回一个指向const的指针\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e防止内存耗尽抛出的异常：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e如果程序用光了可用的自由空间，\u003ccode\u003enew\u003c/code\u003e 默认会抛出类型为\u003ccode\u003ebad_alloc\u003c/code\u003e的异常，可以通过使用**定位\u003ccode\u003enew\u003c/code\u003e**的方式组织抛出异常\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eint *p1 = new int\u003c/code\u003e \t// 分配失败，抛出\u003ccode\u003ebad_alloc\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eint *p1 = new (nothrow) int\u003c/code\u003e // 分配失败，返回一个空指针\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e释放动态内存\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e传递给\u003ccode\u003edelete\u003c/code\u003e 通过\u003ccode\u003enew\u003c/code\u003e获得的指针：销毁给定的指针指向的对象；释放对应的内存，\u003cstrong\u003e有内置指针new管理的动态内存在显示释放之前都会一直存在\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e动态内存管理常见问题：\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e忘记\u003ccode\u003edelete\u003c/code\u003e内存，导致\u003cstrong\u003e内存泄漏\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e使用已经释放过的内存。可以通过释放内存后将指针置为空来解决\u003c/p\u003e\n\u003cp\u003e但是只能解决单一的指针，若多个指针指向同一个对象，就会导致别的指针无效\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003eint\u003c/span\u003e *\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e(\u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e(\u003cspan\u003e42\u003c/span\u003e))\u003c/span\u003e\u003c/span\u003e;\t\u003cspan\u003e// p指向动态内存\u003c/span\u003e\n\u003cspan\u003eauto\u003c/span\u003e q = p;\t\t\u003cspan\u003e// p和q指向相同的内存\u003c/span\u003e\n\u003cspan\u003edelete\u003c/span\u003e p;\t\t\u003cspan\u003e// p和q均无效\u003c/span\u003e\np = \u003cspan\u003enullptr\u003c/span\u003e;\t\u003cspan\u003e// 置空p，但是！q依然是一个指针，却无效了\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e对同一块内存释放两次。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e**空悬指针：**指向一块曾经保存数据对象但是现在已经无效的内存的指针\u003c/p\u003e\n\u003cp\u003e当\u003ccode\u003edelete\u003c/code\u003e掉一个指针后，指针值就变为无效。但是很多机器仍然保存着（已经释放了的）动态内存的地址。导致 这个指针可能依然保存之前的值，但是它之后会变成什么样子已经不是你自己能控制的了，就像你把房子卖给了别人，下次再到这个地址看看，可能还是你的房子，也可能已经被改成公共厕所了。这种指针就叫做空悬指针\u003c/p\u003e\n\u003ch4 id=\"user-content-shared_ptr和new结合使用\"\u003e\u003ca href=\"#shared_ptr%E5%92%8Cnew%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e\u003ccode\u003eshared_ptr\u003c/code\u003e和\u003ccode\u003enew\u003c/code\u003e结合使用\u003c/h4\u003e\n\u003cp\u003e接受指针参数的智能指针构造函数是explicit的（无法将内置指针隐式转换为一个智能指针），因此必须直接初始化一个智能指针\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eshared_ptr\u0026#x3C;int\u003e p1 = new int(1024)\u003c/code\u003e \t// 错误 打算将 \u003ccode\u003enew\u003c/code\u003e 内置指针转换为智能指针\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eshared_ptr\u0026#x3C;int\u003e p1(new int(1024))\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象。但是，如果我们\u003cstrong\u003e提供自己的delete操作\u003c/strong\u003e，我们\u003cstrong\u003e可以将智能指针绑定到一个指向其他类型的资源的指针上\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e不要混合使用普通指针和智能指针\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eprocess\u003c/span\u003e\u003cspan\u003e(shared_ptr\u0026#x3C;\u003cspan\u003eint\u003c/span\u003e\u003e ptr)\u003c/span\u003e\u003c/span\u003e{\n} \u003cspan\u003e// ptr 离开作用域，被销毁\u003c/span\u003e\n\n\u003cspan\u003e\u003cspan\u003eint\u003c/span\u003e *\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e(\u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e(\u003cspan\u003e1024\u003c/span\u003e))\u003c/span\u003e\u003c/span\u003e; \u003cspan\u003e// x 是一个普通指针，而不是一个智能指针\u003c/span\u003e\n\u003cspan\u003eprocess\u003c/span\u003e(x);\t\u003cspan\u003e// error shared_ptr 是explicit的\u003c/span\u003e\n\u003cspan\u003eprocess\u003c/span\u003e(\u003cspan\u003eshared_ptr\u003c/span\u003e\u0026#x3C;\u003cspan\u003eint\u003c/span\u003e\u003e(x))\t\u003cspan\u003e// 合法！但是 x 的内存会被释放，导致下一行的j获取不到值\u003c/span\u003e\n\u003cspan\u003eint\u003c/span\u003e j = *x;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e不要使用get函数返回值初始化另一个智能指针或为指针指针赋值：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e智能指针的\u003ccode\u003eget\u003c/code\u003e函数返回一个内置指针，指向智能指针管理的对象。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eget\u003c/code\u003e 用来将指针的访问权限传递给代码，即只有在确保代码不会delete指针时，才能使用\u003ccode\u003eget\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eshared_ptr\u0026#x3C;\u003cspan\u003eint\u003c/span\u003e\u003e \u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e(\u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e(\u003cspan\u003e42\u003c/span\u003e))\u003c/span\u003e\u003c/span\u003e;\n\u003cspan\u003eint\u003c/span\u003e *q = p.\u003cspan\u003eget\u003c/span\u003e();\n{\n\t\u003cspan\u003eshared_ptr\u003c/span\u003e\u0026#x3C;\u003cspan\u003eint\u003c/span\u003e\u003e(q);\n} \u003cspan\u003e// 程序结束，q被销毁，指向的内存被释放，p为空悬指针\u003c/span\u003e\n\u003cspan\u003eint\u003c/span\u003e foo = *p;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eshared_ptr 其他操作：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eshared_ptr.reset()\u003c/code\u003e 将新指针赋予原先智能指针\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eshared_ptr.unique()\u003c/code\u003e 检查自己是不是当前对象仅有的用户，即计数器是1\u003c/p\u003e\n\u003ch4 id=\"user-content-使用智能指针优化程序异常\"\u003e\u003ca href=\"#%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E5%BC%82%E5%B8%B8\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e使用智能指针优化程序异常\u003c/h4\u003e\n\u003cp\u003e异常发生后，析构函数可能不会正常运行，使用智能指针，即使程序块提前结束，也会将多余的内存释放。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e智能指针使用规范：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e不使用相同的内置指针初始化（或reset）多个智能指针\u003c/li\u003e\n\u003cli\u003e不delete get() 返回的指针\u003c/li\u003e\n\u003cli\u003e不使用get() 初始化或reset 另一个智能指针\u003c/li\u003e\n\u003cli\u003e使用 get() 返回的指针，当最后一个智能指针销毁时，内置指针成为悬空指针\u003c/li\u003e\n\u003cli\u003e当智能指针管理的不是new分配的内存，需要传递给一个删除器\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"user-content-unique_ptr使用\"\u003e\u003ca href=\"#unique_ptr%E4%BD%BF%E7%94%A8\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003eunique_ptr使用\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eunique_ptr\u003c/code\u003e 与 给定对象一一对应， 因此不支持普通的拷贝和赋值操作\u003c/p\u003e\n\u003cp\u003e通过绑定到一个\u003ccode\u003enew\u003c/code\u003e返回的指针初始化， 没有类似 make_shared 的方法\u003c/p\u003e\n\u003cp\u003e可以通过调用\u003ccode\u003erelease\u003c/code\u003e 或\u003ccode\u003e reset\u003c/code\u003e 将指针的所有权从 一个 \u003ccode\u003eunique_ptr\u003c/code\u003e 转移给另一个 \u003ccode\u003eunique_ptr\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eunique_ptr\u0026#x3C;string\u003e \u003cspan\u003ep1\u003c/span\u003e \u003cspan\u003e(\u003cspan\u003enew\u003c/span\u003e string(\u003cspan\u003e\"Hello\"\u003c/span\u003e))\u003c/span\u003e\u003c/span\u003e;\n\u003cspan\u003eunique_ptr\u0026#x3C;string\u003e \u003cspan\u003ep2\u003c/span\u003e\u003cspan\u003e(p1.release())\u003c/span\u003e\u003c/span\u003e; \u003cspan\u003e// 将所有权p1转向p2， release将 p1 置为空\u003c/span\u003e\n\u003cspan\u003eunique_ptr\u0026#x3C;string\u003e \u003cspan\u003ep3\u003c/span\u003e\u003cspan\u003e(\u003cspan\u003enew\u003c/span\u003e string(\u003cspan\u003e\"world\"\u003c/span\u003e))\u003c/span\u003e\np2.\u003cspan\u003ereset\u003c/span\u003e\u003cspan\u003e(p3.release())\u003c/span\u003e \u003cspan\u003e// reset 释放了原来 p2 指向的内存\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003erelease\u003c/code\u003e返回当前保存的指针并将其置为空。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ereset\u003c/code\u003e接受一个可选的指针参数，令\u003ccode\u003euniqeu_ptr\u003c/code\u003e重新指向给定的指针。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e可以拷贝或赋值一个将要被销毁的unique_ptr\u003c/strong\u003e. 例如从函数中返回一个\u003ccode\u003eunique_ptr\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eunique_ptr\u0026#x3C;\u003cspan\u003eint\u003c/span\u003e\u003e \u003cspan\u003eclone\u003c/span\u003e\u003cspan\u003e(\u003cspan\u003eint\u003c/span\u003e p)\u003c/span\u003e\u003c/span\u003e{\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eunique_ptr\u003c/span\u003e\u0026#x3C;\u003cspan\u003eint\u003c/span\u003e\u003e(\u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e(p))\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e向 unique_ptr 传递删除器\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e重载一个 unique_ptr 的删除器会影响到 unique_ptr类型并且决定如何构造该类型的对象，删除器必须在\u003cstrong\u003e尖括号中指向类型之后提供删除器类型\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eunique_ptr\u0026#x3C;objT,delT p(new objT, fcn)\u003e;\u003c/code\u003e\u003c/p\u003e\n\u003ch4 id=\"user-content-weak_ptr\"\u003e\u003ca href=\"#weak_ptr\" aria-hidden=\"true\" tabindex=\"-1\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/a\u003eweak_ptr\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eweak_ptr\u003c/code\u003e ：不控制所指向对象生存期的智能指针\n指向一个\u003ccode\u003eshared_ptr\u003c/code\u003e管理的对象，当其绑定到一个\u003ccode\u003eshared_ptr\u003c/code\u003e 上时，不会改变\u003ccode\u003eshared_ptr\u003c/code\u003e的引用计数.\u003c/p\u003e\n\u003cp\u003e| API               | 说明                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| weak_ptr w     | 空 weak_ptr，指向类型为T的对象                               |\n| weak_ptr w(sp) | 与shared_ptr sp指向相同对象的weak_ptr. T可以转换为sp指向的类型 |\n| w=p               | p可以是一个shared_ptr 或者 weak_ptr，w与p共享家对象          |\n| w.reset()         | 将w置为空                                                    |\n| w.use_count()     | 与w共享的shared_ptr 的计数器数量                             |\n| w.expired()       | 若 w.use_count() 为0， 返回true。反之返回 false              |\n| w.lock()          | 若 expired 为 true，返回一个空的shared_ptr,否则返回指向w的对象的 shared_ptr |\u003c/p\u003e\n\u003cp\u003e由于\u003ccode\u003eweak_ptr\u003c/code\u003e 指向的对象可能不存在，所以必须在使用前使用\u003ccode\u003ewp.lock()\u003c/code\u003e判断 weak_ptr 指向的对象是否存在\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eif(shared_ptr\u0026#x3C;int\u003e np = wp.lock()){}\t// 如果np不为空则条件成立，wp对应了一个shared_ptr对象\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eweak_ptr\u003c/code\u003e可以用来解决循环队列 \u003ccode\u003eshared_ptr\u003c/code\u003e 循环引用的问题。\u003c/p\u003e\n","title":"读书笔记 C++ 动态内存及使用","date":"2021-03-25T13:39:08.000Z","description":"C++通过new动态分配内存","tag":"Cpp"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"读书笔记 C++ 动态内存及使用"},"buildId":"N-OKAoxaKmOR4Qwc77KAc","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>